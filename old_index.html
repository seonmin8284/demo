<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>웹툰 AI 에디터</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a1a;
            color: #fff;
            height: 100vh;
            overflow: hidden;
        }

        .app-container {
            display: flex;
            height: 100vh;
        }

        /* 좌측 도구 패널 */
        .left-panel {
            width: 250px;
            background: #2d2d2d;
            border-right: 1px solid #444;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* 탭 헤더 */
        .tab-header {
            display: flex;
            background: #1a1a1a;
            border-bottom: 1px solid #444;
        }

        .tab-button {
            flex: 1;
            padding: 12px 8px;
            background: none;
            border: none;
            color: #aaa;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
            border-bottom: 2px solid transparent;
        }

        .tab-button:hover {
            color: #fff;
            background: #333;
        }

        .tab-button.active {
            color: #0066cc;
            background: #2d2d2d;
            border-bottom-color: #0066cc;
        }

        /* 탭 내용 */
        .tab-content {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .tool-section {
            margin-bottom: 30px;
        }

        .tool-section h3 {
            font-size: 14px;
            color: #aaa;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .tool-button {
            display: block;
            width: 100%;
            padding: 12px;
            margin-bottom: 8px;
            background: #3a3a3a;
            border: none;
            border-radius: 8px;
            color: #fff;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 13px;
        }

        .tool-button:hover {
            background: #4a4a4a;
            transform: translateY(-1px);
        }

        .tool-button.active {
            background: #0066cc;
        }

        .shortcut {
            float: right;
            font-size: 11px;
            color: #aaa;
            font-weight: normal;
            background: rgba(255, 255, 255, 0.1);
            padding: 2px 6px;
            border-radius: 3px;
            margin-left: 8px;
        }

        .tool-button:hover .shortcut {
            color: #fff;
            background: rgba(255, 255, 255, 0.2);
        }

        .tool-button.active .shortcut {
            color: #fff;
            background: rgba(255, 255, 255, 0.2);
        }

        /* 단축키 가이드 */
        .shortcut-guide {
            font-size: 11px;
        }

        .shortcut-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
            padding: 4px 0;
        }

        .key {
            background: #4a4a4a;
            color: #fff;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: monospace;
            font-size: 10px;
            font-weight: bold;
            min-width: 30px;
            text-align: center;
            border: 1px solid #666;
        }

        .action {
            color: #ccc;
            font-size: 10px;
            flex: 1;
            margin-left: 8px;
        }

        .layer-item {
            display: flex;
            align-items: center;
            padding: 8px 12px;
            margin-bottom: 4px;
            background: #3a3a3a;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .layer-item:hover {
            background: #4a4a4a;
        }

        .layer-item.selected {
            background: #0066cc;
        }

        .layer-visibility {
            width: 16px;
            height: 16px;
            margin-right: 8px;
            cursor: pointer;
        }

        .layer-name {
            flex: 1;
            font-size: 12px;
        }

        .add-layer-btn {
            width: 100%;
            padding: 8px;
            background: #444;
            border: 2px dashed #666;
            border-radius: 6px;
            color: #aaa;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }

        .add-layer-btn:hover {
            border-color: #888;
            color: #fff;
        }

        /* 중앙 캔버스 영역 */
        .canvas-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #1a1a1a;
            position: relative;
        }

        .canvas-toolbar {
            height: 50px;
            background: #2d2d2d;
            border-bottom: 1px solid #444;
            display: flex;
            align-items: center;
            padding: 0 20px;
            gap: 15px;
        }

        .zoom-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .zoom-btn {
            width: 30px;
            height: 30px;
            background: #444;
            border: none;
            border-radius: 4px;
            color: #fff;
            cursor: pointer;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .zoom-btn:hover {
            background: #555;
        }

        .zoom-display {
            min-width: 60px;
            text-align: center;
            font-size: 12px;
            color: #aaa;
        }

        .canvas-wrapper {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background: 
                radial-gradient(circle, #333 1px, transparent 1px),
                radial-gradient(circle, #333 1px, transparent 1px);
            background-size: 20px 20px;
            background-position: 0 0, 10px 10px;
        }

        .canvas-area {
            position: relative;
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            overflow: hidden;
        }

        #main-canvas {
            display: block;
            cursor: crosshair;
        }

        .selection-box {
            position: absolute;
            border: 2px dashed #0066cc;
            background: rgba(0, 102, 204, 0.1);
            pointer-events: none;
            display: none;
        }

        /* 우측 AI 챗 패널 */
        .right-panel {
            width: 300px;
            background: #2d2d2d;
            border-left: 1px solid #444;
            display: flex;
            flex-direction: column;
        }

        .chat-header {
            height: 60px;
            background: #363636;
            display: flex;
            align-items: center;
            padding: 0 20px;
            border-bottom: 1px solid #444;
        }

        .chat-header h2 {
            font-size: 16px;
            font-weight: 600;
        }

        .chat-messages {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .message {
            max-width: 85%;
            padding: 12px 16px;
            border-radius: 18px;
            font-size: 14px;
            line-height: 1.4;
        }

        .message.user {
            background: #0066cc;
            color: #fff;
            align-self: flex-end;
            margin-left: auto;
        }

        .message.ai {
            background: #3a3a3a;
            color: #fff;
            align-self: flex-start;
        }

        .chat-input-area {
            padding: 20px;
            border-top: 1px solid #444;
        }

        .chat-input {
            width: 100%;
            padding: 12px 16px;
            background: #3a3a3a;
            border: 1px solid #555;
            border-radius: 8px;
            color: #fff;
            font-size: 14px;
            resize: none;
            outline: none;
            min-height: 80px;
        }

        .chat-input:focus {
            border-color: #0066cc;
        }

        .send-button {
            width: 100%;
            padding: 10px;
            margin-top: 10px;
            background: #0066cc;
            border: none;
            border-radius: 6px;
            color: #fff;
            font-size: 14px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .send-button:hover {
            background: #0077dd;
        }

        .send-button:disabled {
            background: #555;
            cursor: not-allowed;
        }

        /* 브러시 설정 */
        .brush-settings {
            margin-top: 15px;
        }

        .setting-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .setting-row label {
            font-size: 12px;
            color: #aaa;
        }

        .setting-row input[type="range"] {
            width: 60px;
        }

        .color-picker {
            width: 30px;
            height: 30px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        /* 텍스트 도구 */
        .text-input {
            position: absolute;
            background: transparent;
            border: 2px dashed #0066cc;
            color: #333;
            font-family: Arial, sans-serif;
            outline: none;
            resize: none;
            display: none;
            min-width: 100px;
            min-height: 30px;
            padding: 5px;
        }

        /* 상태 표시 */
        .status-bar {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: #fff;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            display: none;
        }

        /* 캐릭터 레퍼런스 시스템 */
        .character-slot {
            width: 80px;
            height: 80px;
            background: #3a3a3a;
            border: 2px dashed #666;
            border-radius: 8px;
            margin-bottom: 10px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            background-size: cover;
            background-position: center;
            position: relative;
            transition: all 0.2s;
        }

        .character-slot:hover {
            border-color: #0066cc;
            transform: translateY(-2px);
        }

        .character-slot.selected {
            border-color: #0066cc;
            box-shadow: 0 0 10px rgba(0, 102, 204, 0.3);
        }

        .character-slot.empty {
            background: #2a2a2a;
        }

        .add-character {
            text-align: center;
            color: #666;
        }

        .add-character span {
            font-size: 24px;
            display: block;
            margin-bottom: 5px;
        }

        .add-character p {
            font-size: 10px;
            margin: 0;
        }

        .character-controls {
            position: absolute;
            top: 5px;
            right: 5px;
        }

        .delete-character {
            background: rgba(255, 0, 0, 0.8);
            color: white;
            border: none;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            font-size: 12px;
            cursor: pointer;
            display: none;
        }

        .character-slot:hover .delete-character {
            display: block;
        }

        .character-info {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 3px;
            font-size: 10px;
            text-align: center;
            border-radius: 0 0 6px 6px;
        }

        /* 캐릭터 모달 */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .modal-content {
            background: #2d2d2d;
            border-radius: 10px;
            padding: 20px;
            width: 400px;
            max-width: 90vw;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .modal-title {
            color: #fff;
            font-size: 18px;
            margin: 0;
        }

        .close-modal {
            background: none;
            border: none;
            color: #aaa;
            font-size: 24px;
            cursor: pointer;
        }

        .close-modal:hover {
            color: #fff;
        }

        .upload-area {
            border: 2px dashed #666;
            border-radius: 8px;
            padding: 40px 20px;
            text-align: center;
            margin-bottom: 20px;
            cursor: pointer;
            transition: border-color 0.2s;
        }

        .upload-area:hover {
            border-color: #0066cc;
        }

        .upload-area.dragover {
            border-color: #0066cc;
            background: rgba(0, 102, 204, 0.1);
        }

        .upload-content {
            color: #aaa;
        }

        .upload-icon {
            font-size: 48px;
            margin-bottom: 10px;
        }

        #imagePreview {
            max-width: 100%;
            max-height: 200px;
            border-radius: 8px;
            display: none;
        }

        .character-name-input {
            width: 100%;
            padding: 10px;
            background: #3a3a3a;
            border: 1px solid #555;
            border-radius: 6px;
            color: #fff;
            margin-bottom: 20px;
        }

        .modal-buttons {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }

        .modal-button {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
        }

        .modal-button.primary {
            background: #0066cc;
            color: white;
        }

        .modal-button.secondary {
            background: #666;
            color: white;
        }

        .modal-button:hover {
            opacity: 0.8;
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- 좌측 도구 패널 -->
        <div class="left-panel">
            <!-- 탭 헤더 -->
            <div class="tab-header">
                <button class="tab-button active" data-tab="tools">🛠️ 도구</button>
                <button class="tab-button" data-tab="characters">🎭 캐릭터</button>
            </div>

            <!-- 도구 탭 -->
            <div class="tab-content active" data-tab-content="tools">
                <div class="tool-section">
                    <h3>도구</h3>
                    <button class="tool-button active" data-tool="select">📍 선택 도구 <span class="shortcut">V</span></button>
                    <button class="tool-button" data-tool="brush">🖌️ 브러시 <span class="shortcut">B</span></button>
                    <button class="tool-button" data-tool="eraser">🧹 지우개 <span class="shortcut">E</span></button>
                    <button class="tool-button" data-tool="text">📝 텍스트 <span class="shortcut">T</span></button>
                    <button class="tool-button" data-tool="shape">⭕ 도형</button>
                </div>

                <div class="tool-section">
                    <h3>브러시 설정</h3>
                    <div class="brush-settings">
                        <div class="setting-row">
                            <label>크기:</label>
                            <input type="range" id="brushSize" min="1" max="50" value="5">
                            <span id="sizeValue">5</span>
                        </div>
                        <div class="setting-row">
                            <label>색상:</label>
                            <input type="color" id="brushColor" class="color-picker" value="#000000">
                        </div>
                        <div class="setting-row">
                            <label>투명도:</label>
                            <input type="range" id="brushOpacity" min="0" max="100" value="100">
                            <span id="opacityValue">100%</span>
                        </div>
                    </div>
                </div>

                <div class="tool-section">
                    <h3>레이어</h3>
                    <div id="layers-list">
                        <div class="layer-item selected" data-layer="0">
                            <input type="checkbox" class="layer-visibility" checked>
                            <span class="layer-name">배경</span>
                        </div>
                        <div class="layer-item" data-layer="1">
                            <input type="checkbox" class="layer-visibility" checked>
                            <span class="layer-name">캐릭터</span>
                        </div>
                        <div class="layer-item" data-layer="2">
                            <input type="checkbox" class="layer-visibility" checked>
                            <span class="layer-name">대사</span>
                        </div>
                    </div>
                    <div class="add-layer-btn" onclick="addLayer()">+ 새 레이어 추가</div>
                </div>

                <div class="tool-section">
                    <h3>단축키</h3>
                    <div class="shortcut-guide">
                        <div class="shortcut-item">
                            <span class="key">Del</span>
                            <span class="action">선택된 객체 삭제</span>
                        </div>
                        <div class="shortcut-item">
                            <span class="key">Esc</span>
                            <span class="action">선택 해제</span>
                        </div>
                        <div class="shortcut-item">
                            <span class="key">Ctrl+Z</span>
                            <span class="action">실행 취소</span>
                        </div>
                        <div class="shortcut-item">
                            <span class="key">Ctrl+Shift+Z</span>
                            <span class="action">다시 실행</span>
                        </div>
                        <div class="shortcut-item">
                            <span class="key">Ctrl+A</span>
                            <span class="action">전체 선택</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 캐릭터 탭 -->
            <div class="tab-content" data-tab-content="characters">
                <div class="tool-section">
                    <h3>캐릭터 레퍼런스</h3>
                    <div id="character-gallery">
                        <div class="character-slot empty" onclick="addCharacterReference()">
                            <div class="add-character">
                                <span>+</span>
                                <p>캐릭터 추가</p>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="tool-section">
                    <h3>액션</h3>
                    <div class="reference-controls">
                        <button class="tool-button" onclick="generateWithReference()">🎭 레퍼런스로 생성</button>
                        <button class="tool-button" onclick="extractCharacter()">✂️ 캐릭터 추출</button>
                    </div>
                </div>

                <div class="tool-section">
                    <h3>사용법</h3>
                    <div class="usage-guide" style="font-size: 11px; color: #aaa; line-height: 1.4;">
                        <p style="margin-bottom: 8px;">1. 캐릭터 이미지를 업로드합니다</p>
                        <p style="margin-bottom: 8px;">2. 캐릭터를 클릭하여 선택합니다</p>
                        <p style="margin-bottom: 8px;">3. 캔버스에서 영역을 선택합니다</p>
                        <p style="margin-bottom: 8px;">4. '레퍼런스로 생성' 클릭합니다</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- 중앙 캔버스 영역 -->
        <div class="canvas-container">
            <div class="canvas-toolbar">
                <div class="zoom-control">
                    <button class="zoom-btn" onclick="zoomOut()">-</button>
                    <span class="zoom-display" id="zoomDisplay">100%</span>
                    <button class="zoom-btn" onclick="zoomIn()">+</button>
                </div>
                <button class="tool-button" onclick="clearCanvas()">🗑️ 전체 지우기</button>
                <button class="tool-button" onclick="exportImage()">💾 내보내기 <span class="shortcut">Ctrl+S</span></button>
            </div>

            <div class="canvas-wrapper">
                <div class="canvas-area" id="canvasArea">
                    <canvas id="main-canvas" width="800" height="600"></canvas>
                    <div class="selection-box" id="selectionBox"></div>
                    <textarea class="text-input" id="textInput"></textarea>
                </div>
            </div>
            
            <div class="status-bar" id="statusBar">준비</div>
        </div>

        <!-- 우측 AI 챗 패널 -->
        <div class="right-panel">
            <div class="chat-header">
                <h2>🤖 AI 어시스턴트</h2>
            </div>
            
            <div class="chat-messages" id="chatMessages">
                <div class="message ai">
                    안녕하세요! 웹툰 제작을 도와드릴게요. 🎨<br>
                    <br>
                    다음과 같은 기능을 사용할 수 있습니다:<br>
                    • 선택된 영역의 이미지 편집<br>
                    • 텍스트와 이미지 조합 편집<br>
                    • 웹툰 스타일 변환<br>
                    • 캐릭터 일관성 유지<br>
                    <br>
                    영역을 선택하고 편집 요청을 해주세요!
                </div>
            </div>

            <div class="chat-input-area">
                <textarea id="chatInput" class="chat-input" placeholder="여기에 편집 요청을 입력하세요... 예: '이 캐릭터의 표정을 화난 표정으로 바꿔주세요'"></textarea>
                <button class="send-button" onclick="sendMessage()">편집 요청 보내기</button>
            </div>
        </div>
    </div>

    <!-- 캐릭터 추가 모달 -->
    <div id="characterModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">캐릭터 추가</h2>
                <button class="close-modal" onclick="closeCharacterModal()">&times;</button>
            </div>
            
            <div id="uploadArea" class="upload-area">
                <div class="upload-content">
                    <div class="upload-icon">📁</div>
                    <p>이미지를 드래그하거나 클릭하여 업로드</p>
                    <p style="font-size: 12px; color: #666;">PNG, JPG 지원</p>
                </div>
                <img id="imagePreview" alt="미리보기">
            </div>
            
            <input type="file" id="characterFileInput" accept="image/*" style="display: none;">
            
            <input type="text" id="characterNameInput" class="character-name-input" placeholder="캐릭터 이름을 입력하세요">
            
            <div class="modal-buttons">
                <button class="modal-button secondary" onclick="closeCharacterModal()">취소</button>
                <button class="modal-button primary" onclick="saveCharacterReference()">저장</button>
            </div>
        </div>
    </div>

    <!-- 캐릭터 툴팁 -->
    <div id="characterTooltip" style="position: absolute; background: #2d2d2d; border: 1px solid #555; border-radius: 6px; padding: 10px; display: none; z-index: 1001; max-width: 200px;">
    </div>

    <script>
        // 전역 변수
        let canvas, ctx;
        let currentTool = 'select';
        let isDrawing = false;
        let isSelecting = false;
        let startX, startY, endX, endY;
        let layers = [];
        let currentLayer = 0;
        let zoomLevel = 1;
        let selectedArea = null;
        
        // 객체 관리
        let drawingObjects = []; // 모든 그린 객체들 저장
        let selectedObject = null;
        let selectedObjects = []; // 다중 선택된 객체들
        let objectId = 0;
        let currentStroke = null;
        
        // 객체 조작 상태
        let isDragging = false;
        let isResizing = false;
        let dragStartX, dragStartY;
        let currentHandle = null; // 현재 선택된 크기조정 핸들
        
        // 캐릭터 레퍼런스 시스템
        let characterReferences = [];
        let selectedCharacter = null;

        // 초기화
        window.onload = function() {
            canvas = document.getElementById('main-canvas');
            ctx = canvas.getContext('2d');
            
            // 레이어 초기화
            initLayers();
            
            // 이벤트 리스너 설정
            setupEventListeners();
            
            // 브러시 설정 이벤트
            setupBrushControls();
            
            // 캐릭터 시스템 초기화
            setupCharacterSystem();
            updateCharacterGallery();
            
            showStatus('웹툰 에디터가 준비되었습니다!');
        };

        function initLayers() {
            layers = [
                { name: '배경', visible: true, canvas: createLayerCanvas() },
                { name: '캐릭터', visible: true, canvas: createLayerCanvas() },
                { name: '대사', visible: true, canvas: createLayerCanvas() }
            ];
        }

        function createLayerCanvas() {
            const layerCanvas = document.createElement('canvas');
            layerCanvas.width = canvas.width;
            layerCanvas.height = canvas.height;
            return layerCanvas;
        }

        function setupEventListeners() {
            // 마우스 이벤트
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('dblclick', handleDoubleClick);
            
            // 도구 선택
            document.querySelectorAll('.tool-button[data-tool]').forEach(btn => {
                btn.addEventListener('click', function() {
                    selectTool(this.dataset.tool);
                });
            });

            // 레이어 선택
            document.addEventListener('click', function(e) {
                if (e.target.closest('.layer-item')) {
                    selectLayer(e.target.closest('.layer-item').dataset.layer);
                }
            });

            // 키보드 단축키
            document.addEventListener('keydown', handleKeydown);
            
            // 탭 전환
            setupTabs();
        }

        function setupTabs() {
            // 탭 버튼 클릭 이벤트
            document.querySelectorAll('.tab-button').forEach(button => {
                button.addEventListener('click', function() {
                    const tabName = this.dataset.tab;
                    switchTab(tabName);
                });
            });
        }

        function switchTab(tabName) {
            // 모든 탭 버튼 비활성화
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // 모든 탭 내용 숨기기
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            
            // 선택된 탭 활성화
            document.querySelector(`[data-tab="${tabName}"]`).classList.add('active');
            document.querySelector(`[data-tab-content="${tabName}"]`).classList.add('active');
        }

        function setupBrushControls() {
            const brushSize = document.getElementById('brushSize');
            const sizeValue = document.getElementById('sizeValue');
            const brushOpacity = document.getElementById('brushOpacity');
            const opacityValue = document.getElementById('opacityValue');

            brushSize.addEventListener('input', function() {
                sizeValue.textContent = this.value;
            });

            brushOpacity.addEventListener('input', function() {
                opacityValue.textContent = this.value + '%';
            });
        }

        function selectTool(tool) {
            currentTool = tool;
            document.querySelectorAll('.tool-button[data-tool]').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelector(`[data-tool="${tool}"]`).classList.add('active');
            
            // 커서 변경
            switch(tool) {
                case 'select':
                    canvas.style.cursor = 'default';
                    break;
                case 'brush':
                    canvas.style.cursor = 'crosshair';
                    break;
                case 'eraser':
                    canvas.style.cursor = 'grab';
                    break;
                case 'text':
                    canvas.style.cursor = 'text';
                    break;
            }
            
            showStatus(`${tool} 도구가 선택되었습니다.`);
        }

        function selectLayer(layerIndex) {
            currentLayer = parseInt(layerIndex);
            document.querySelectorAll('.layer-item').forEach(item => {
                item.classList.remove('selected');
            });
            document.querySelector(`[data-layer="${layerIndex}"]`).classList.add('selected');
            
            showStatus(`레이어 '${layers[currentLayer].name}' 선택됨`);
        }

        function handleMouseDown(e) {
            const rect = canvas.getBoundingClientRect();
            startX = (e.clientX - rect.left) / zoomLevel;
            startY = (e.clientY - rect.top) / zoomLevel;

            switch(currentTool) {
                case 'select':
                    // 크기 조정 핸들 확인
                    currentHandle = getResizeHandle(startX, startY);
                    if (currentHandle && selectedObject) {
                        isResizing = true;
                        dragStartX = startX;
                        dragStartY = startY;
                    } else {
                        // 클릭 위치에 객체가 있는지 확인
                        const clickedObject = getObjectAt(startX, startY);
                        if (clickedObject) {
                            selectObject(clickedObject);
                            // 선택된 객체에서 드래그 시작
                            isDragging = true;
                            dragStartX = startX;
                            dragStartY = startY;
                        } else {
                            // 객체가 없으면 영역 선택 모드
                            selectedObject = null;
                            selectedObjects = [];
                            isSelecting = true;
                            hideSelectionBox();
                            redrawCanvas();
                        }
                    }
                    break;
                case 'brush':
                    isDrawing = true;
                    drawBrush(startX, startY);
                    break;
                case 'eraser':
                    isDrawing = true;
                    erase(startX, startY);
                    break;
                case 'text':
                    addTextInput(startX, startY);
                    break;
            }
        }

        function handleMouseMove(e) {
            const rect = canvas.getBoundingClientRect();
            const currentX = (e.clientX - rect.left) / zoomLevel;
            const currentY = (e.clientY - rect.top) / zoomLevel;

            if (isSelecting && currentTool === 'select') {
                updateSelectionBox(startX, startY, currentX, currentY);
            } else if (isDragging && currentTool === 'select') {
                // 객체 이동
                const deltaX = currentX - dragStartX;
                const deltaY = currentY - dragStartY;
                moveSelectedObject(deltaX, deltaY);
                dragStartX = currentX;
                dragStartY = currentY;
            } else if (isResizing && currentTool === 'select') {
                // 객체 크기 조정
                resizeSelectedObject(currentX, currentY);
            } else if (isDrawing && currentTool === 'brush') {
                // 연속적인 브러시 스트로크
                drawBrush(currentX, currentY);
            } else if (isDrawing && currentTool === 'eraser') {
                erase(currentX, currentY);
            } else if (currentTool === 'select' && !isSelecting && !isDragging && !isResizing) {
                // 커서 스타일 업데이트
                updateCursorForSelect(currentX, currentY);
            }
        }

        function handleMouseUp(e) {
            const rect = canvas.getBoundingClientRect();
            endX = (e.clientX - rect.left) / zoomLevel;
            endY = (e.clientY - rect.top) / zoomLevel;

            if (isSelecting && currentTool === 'select') {
                finalizeSelection();
                isSelecting = false;
            }
            
            if (isDragging) {
                isDragging = false;
            }
            
            if (isResizing) {
                isResizing = false;
                currentHandle = null;
            }
            
            if (isDrawing) {
                // 스트로크 완료
                currentStroke = null;
                isDrawing = false;
            }
        }

        function updateSelectionBox(x1, y1, x2, y2) {
            const selectionBox = document.getElementById('selectionBox');
            const left = Math.min(x1, x2) * zoomLevel;
            const top = Math.min(y1, y2) * zoomLevel;
            const width = Math.abs(x2 - x1) * zoomLevel;
            const height = Math.abs(y2 - y1) * zoomLevel;

            selectionBox.style.left = left + 'px';
            selectionBox.style.top = top + 'px';
            selectionBox.style.width = width + 'px';
            selectionBox.style.height = height + 'px';
            selectionBox.style.display = 'block';
        }

        function finalizeSelection() {
            const selectionRect = {
                x: Math.min(startX, endX),
                y: Math.min(startY, endY),
                width: Math.abs(endX - startX),
                height: Math.abs(endY - startY)
            };
            
            // 선택 영역 내에 있는 객체들 찾기
            selectedObjects = [];
            drawingObjects.forEach(obj => {
                if (obj.layer === currentLayer && layers[obj.layer].visible && 
                    isObjectInSelectionRect(obj, selectionRect)) {
                    selectedObjects.push(obj);
                }
            });
            
            if (selectedObjects.length > 0) {
                selectedObject = null; // 단일 선택 해제
                showStatus(`${selectedObjects.length}개 객체 선택됨`);
            } else {
                selectedArea = selectionRect;
                showStatus(`영역 선택됨: ${Math.round(selectionRect.width)}x${Math.round(selectionRect.height)}`);
            }
        }
        
        function isObjectInSelectionRect(obj, rect) {
            // 객체의 경계 박스가 선택 영역과 겹치는지 확인
            return !(obj.bounds.maxX < rect.x || 
                     obj.bounds.minX > rect.x + rect.width ||
                     obj.bounds.maxY < rect.y || 
                     obj.bounds.minY > rect.y + rect.height);
        }

        function hideSelectionBox() {
            document.getElementById('selectionBox').style.display = 'none';
        }

        function drawBrush(x, y) {
            const brushSize = document.getElementById('brushSize').value;
            const brushColor = document.getElementById('brushColor').value;
            const brushOpacity = document.getElementById('brushOpacity').value / 100;

            // 새로운 스트로크 시작
            if (!isDrawing || !currentStroke) {
                currentStroke = {
                    id: objectId++,
                    type: 'brush',
                    layer: currentLayer,
                    points: [{x: x, y: y}],
                    style: {
                        color: brushColor,
                        size: brushSize,
                        opacity: brushOpacity,
                        lineCap: 'round',
                        lineJoin: 'round'
                    },
                    bounds: {
                        minX: x, maxX: x,
                        minY: y, maxY: y
                    }
                };
                drawingObjects.push(currentStroke);
            } else {
                // 기존 스트로크에 점 추가
                currentStroke.points.push({x: x, y: y});
                // 경계 업데이트
                currentStroke.bounds.minX = Math.min(currentStroke.bounds.minX, x);
                currentStroke.bounds.maxX = Math.max(currentStroke.bounds.maxX, x);
                currentStroke.bounds.minY = Math.min(currentStroke.bounds.minY, y);
                currentStroke.bounds.maxY = Math.max(currentStroke.bounds.maxY, y);
            }
            
            redrawCanvas();
        }

        function erase(x, y) {
            const brushSize = parseInt(document.getElementById('brushSize').value);
            const eraseRadius = brushSize / 2;
            
            // 지우개 범위 내에 있는 객체들 찾기
            const objectsToRemove = [];
            
            drawingObjects.forEach(obj => {
                if (obj.layer === currentLayer && isObjectInEraseArea(obj, x, y, eraseRadius)) {
                    objectsToRemove.push(obj);
                }
            });
            
            // 찾은 객체들 삭제
            objectsToRemove.forEach(obj => {
                const index = drawingObjects.indexOf(obj);
                if (index > -1) {
                    drawingObjects.splice(index, 1);
                    if (selectedObject === obj) {
                        selectedObject = null;
                    }
                    // 다중 선택에서도 제거
                    const selectedIndex = selectedObjects.indexOf(obj);
                    if (selectedIndex > -1) {
                        selectedObjects.splice(selectedIndex, 1);
                    }
                }
            });
            
            if (objectsToRemove.length > 0) {
                showStatus(`${objectsToRemove.length}개 객체 지움`);
                redrawCanvas();
            }
        }
        
        function isObjectInEraseArea(obj, eraseX, eraseY, eraseRadius) {
            if (obj.type === 'brush') {
                // 브러시 스트로크의 모든 점이 지우개 범위 내에 있는지 확인
                for (let i = 0; i < obj.points.length; i++) {
                    const point = obj.points[i];
                    const distance = Math.sqrt((point.x - eraseX) ** 2 + (point.y - eraseY) ** 2);
                    if (distance <= eraseRadius + obj.style.size / 2) {
                        return true;
                    }
                }
            }
            return false;
        }

        function addTextInput(x, y) {
            const textInput = document.getElementById('textInput');
            textInput.style.left = (x * zoomLevel) + 'px';
            textInput.style.top = (y * zoomLevel) + 'px';
            textInput.style.display = 'block';
            textInput.value = ''; // 기존 값 클리어
            
            // 지연 후 포커스 (DOM 업데이트 대기)
            setTimeout(() => {
                textInput.focus();
            }, 10);
            
            // 완료 처리 함수
            const finishTextInput = () => {
                const text = textInput.value.trim();
                if (text) {
                    addTextToCanvas(x, y, text);
                }
                textInput.style.display = 'none';
                textInput.value = '';
                textInput.onblur = null;
                textInput.onkeydown = null;
            };
            
            // Enter 키로 완료
            textInput.onkeydown = function(e) {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    finishTextInput();
                }
                if (e.key === 'Escape') {
                    textInput.style.display = 'none';
                    textInput.value = '';
                    textInput.onblur = null;
                    textInput.onkeydown = null;
                }
            };
            
            // 포커스 잃으면 완료
            textInput.onblur = finishTextInput;
        }

        function addTextToCanvas(x, y, text) {
            const brushColor = document.getElementById('brushColor').value;
            const fontSize = 20;
            
            // 텍스트 객체 생성
            const textObject = {
                id: objectId++,
                type: 'text',
                layer: currentLayer,
                x: x,
                y: y,
                text: text,
                style: {
                    color: brushColor,
                    font: `${fontSize}px Arial`,
                    fontSize: fontSize
                },
                bounds: {
                    minX: x,
                    maxX: x + text.length * fontSize * 0.6, // 대략적인 텍스트 폭
                    minY: y - fontSize,
                    maxY: y
                }
            };
            
            drawingObjects.push(textObject);
            redrawCanvas();
        }

        function redrawCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 레이어별로 객체 렌더링
            layers.forEach((layer, layerIndex) => {
                if (layer.visible) {
                    // 해당 레이어의 객체들만 렌더링
                    const layerObjects = drawingObjects.filter(obj => obj.layer === layerIndex);
                    layerObjects.forEach(obj => {
                        drawObject(ctx, obj);
                    });
                }
            });
            
            // 선택된 객체 하이라이트
            if (selectedObject) {
                drawObjectHighlight(ctx, selectedObject);
            }
            
            // 다중 선택된 객체들 하이라이트
            selectedObjects.forEach(obj => {
                drawObjectHighlight(ctx, obj);
            });
        }
        
        function drawObject(context, obj) {
            if (obj.type === 'brush' && obj.points.length > 0) {
                context.save();
                context.globalAlpha = obj.style.opacity;
                context.strokeStyle = obj.style.color;
                context.lineWidth = obj.style.size;
                context.lineCap = obj.style.lineCap;
                context.lineJoin = obj.style.lineJoin;
                
                context.beginPath();
                context.moveTo(obj.points[0].x, obj.points[0].y);
                
                for (let i = 1; i < obj.points.length; i++) {
                    context.lineTo(obj.points[i].x, obj.points[i].y);
                }
                
                context.stroke();
                context.restore();
            } else if (obj.type === 'text') {
                context.save();
                context.fillStyle = obj.style.color;
                context.font = obj.style.font;
                context.fillText(obj.text, obj.x, obj.y);
                context.restore();
            } else if (obj.type === 'image' && obj.image) {
                context.save();
                context.drawImage(obj.image, obj.x, obj.y, obj.width, obj.height);
                context.restore();
            }
        }
        
        function drawObjectHighlight(context, obj) {
            context.save();
            context.strokeStyle = '#0066cc';
            context.lineWidth = 2;
            context.setLineDash([5, 5]);
            
            // 객체 경계 박스 그리기
            const padding = 5;
            const rect = {
                x: obj.bounds.minX - padding,
                y: obj.bounds.minY - padding,
                width: obj.bounds.maxX - obj.bounds.minX + padding * 2,
                height: obj.bounds.maxY - obj.bounds.minY + padding * 2
            };
            
            context.strokeRect(rect.x, rect.y, rect.width, rect.height);
            
            // 크기 조정 핸들 그리기 (단일 선택된 객체만)
            if (obj === selectedObject) {
                context.setLineDash([]);
                context.fillStyle = '#0066cc';
                context.strokeStyle = '#ffffff';
                context.lineWidth = 1;
                
                const handleSize = 8;
                const handles = [
                    { x: rect.x, y: rect.y }, // nw
                    { x: rect.x + rect.width/2, y: rect.y }, // n
                    { x: rect.x + rect.width, y: rect.y }, // ne
                    { x: rect.x, y: rect.y + rect.height/2 }, // w
                    { x: rect.x + rect.width, y: rect.y + rect.height/2 }, // e
                    { x: rect.x, y: rect.y + rect.height }, // sw
                    { x: rect.x + rect.width/2, y: rect.y + rect.height }, // s
                    { x: rect.x + rect.width, y: rect.y + rect.height } // se
                ];
                
                handles.forEach(handle => {
                    context.fillRect(
                        handle.x - handleSize/2, 
                        handle.y - handleSize/2, 
                        handleSize, 
                        handleSize
                    );
                    context.strokeRect(
                        handle.x - handleSize/2, 
                        handle.y - handleSize/2, 
                        handleSize, 
                        handleSize
                    );
                });
            }
            
            context.restore();
        }
        
        function getObjectAt(x, y) {
            // 역순으로 검사 (위에 그려진 객체부터)
            for (let i = drawingObjects.length - 1; i >= 0; i--) {
                const obj = drawingObjects[i];
                
                // 현재 레이어의 객체만 검사
                if (obj.layer !== currentLayer || !layers[obj.layer].visible) {
                    continue;
                }
                
                if (isPointInObject(x, y, obj)) {
                    return obj;
                }
            }
            return null;
        }
        
        function isPointInObject(x, y, obj) {
            if (obj.type === 'brush') {
                // 먼저 경계 박스 확인 (빠른 검사)
                const padding = obj.style.size / 2 + 2;
                if (x < obj.bounds.minX - padding || x > obj.bounds.maxX + padding ||
                    y < obj.bounds.minY - padding || y > obj.bounds.maxY + padding) {
                    return false;
                }
                
                // 브러시 스트로크 선 위의 점인지 확인
                const threshold = obj.style.size / 2 + 3;
                
                for (let i = 0; i < obj.points.length - 1; i++) {
                    const p1 = obj.points[i];
                    const p2 = obj.points[i + 1];
                    
                    if (distanceToLineSegment(x, y, p1.x, p1.y, p2.x, p2.y) <= threshold) {
                        return true;
                    }
                }
                
                // 단일 점인 경우
                if (obj.points.length === 1) {
                    const p = obj.points[0];
                    return Math.sqrt((x - p.x) ** 2 + (y - p.y) ** 2) <= threshold;
                }
            } else if (obj.type === 'text') {
                // 텍스트 경계 박스 내에 있는지 확인
                return x >= obj.bounds.minX && x <= obj.bounds.maxX &&
                       y >= obj.bounds.minY && y <= obj.bounds.maxY;
            }
            return false;
        }
        
        function distanceToLineSegment(px, py, x1, y1, x2, y2) {
            const dx = x2 - x1;
            const dy = y2 - y1;
            const length = Math.sqrt(dx * dx + dy * dy);
            
            if (length === 0) {
                return Math.sqrt((px - x1) ** 2 + (py - y1) ** 2);
            }
            
            const t = Math.max(0, Math.min(1, ((px - x1) * dx + (py - y1) * dy) / (length * length)));
            const projX = x1 + t * dx;
            const projY = y1 + t * dy;
            
            return Math.sqrt((px - projX) ** 2 + (py - projY) ** 2);
        }
        
        function selectObject(obj) {
            selectedObject = obj;
            selectedObjects = []; // 다중 선택 해제
            selectedArea = null; // 기존 영역 선택 해제
            hideSelectionBox();
            redrawCanvas();
            showStatus(`객체 선택됨 (ID: ${obj.id})`);
        }
        
        function moveSelectedObject(deltaX, deltaY) {
            if (!selectedObject) return;
            
            if (selectedObject.type === 'brush') {
                // 브러시 스트로크의 모든 점 이동
                selectedObject.points.forEach(point => {
                    point.x += deltaX;
                    point.y += deltaY;
                });
                // 경계 업데이트
                selectedObject.bounds.minX += deltaX;
                selectedObject.bounds.maxX += deltaX;
                selectedObject.bounds.minY += deltaY;
                selectedObject.bounds.maxY += deltaY;
            } else if (selectedObject.type === 'text') {
                // 텍스트 위치 이동
                selectedObject.x += deltaX;
                selectedObject.y += deltaY;
                // 경계 업데이트
                selectedObject.bounds.minX += deltaX;
                selectedObject.bounds.maxX += deltaX;
                selectedObject.bounds.minY += deltaY;
                selectedObject.bounds.maxY += deltaY;
            }
            
            redrawCanvas();
        }
        
        function getResizeHandle(x, y) {
            if (!selectedObject) return null;
            
            const bounds = selectedObject.bounds;
            const handleSize = 8;
            const padding = 5;
            
            // 8개의 크기 조정 핸들 위치 계산
            const handles = [
                { name: 'nw', x: bounds.minX - padding, y: bounds.minY - padding },
                { name: 'n', x: (bounds.minX + bounds.maxX) / 2, y: bounds.minY - padding },
                { name: 'ne', x: bounds.maxX + padding, y: bounds.minY - padding },
                { name: 'w', x: bounds.minX - padding, y: (bounds.minY + bounds.maxY) / 2 },
                { name: 'e', x: bounds.maxX + padding, y: (bounds.minY + bounds.maxY) / 2 },
                { name: 'sw', x: bounds.minX - padding, y: bounds.maxY + padding },
                { name: 's', x: (bounds.minX + bounds.maxX) / 2, y: bounds.maxY + padding },
                { name: 'se', x: bounds.maxX + padding, y: bounds.maxY + padding }
            ];
            
            // 클릭 위치가 핸들 범위 내에 있는지 확인
            for (let handle of handles) {
                if (x >= handle.x - handleSize/2 && x <= handle.x + handleSize/2 &&
                    y >= handle.y - handleSize/2 && y <= handle.y + handleSize/2) {
                    return handle.name;
                }
            }
            
            return null;
        }
        
        function resizeSelectedObject(currentX, currentY) {
            if (!selectedObject || !currentHandle) return;
            
            const bounds = selectedObject.bounds;
            const originalWidth = bounds.maxX - bounds.minX;
            const originalHeight = bounds.maxY - bounds.minY;
            
            let newBounds = { ...bounds };
            
            // 핸들 위치에 따라 크기 조정
            switch (currentHandle) {
                case 'nw':
                    newBounds.minX = currentX;
                    newBounds.minY = currentY;
                    break;
                case 'n':
                    newBounds.minY = currentY;
                    break;
                case 'ne':
                    newBounds.maxX = currentX;
                    newBounds.minY = currentY;
                    break;
                case 'w':
                    newBounds.minX = currentX;
                    break;
                case 'e':
                    newBounds.maxX = currentX;
                    break;
                case 'sw':
                    newBounds.minX = currentX;
                    newBounds.maxY = currentY;
                    break;
                case 's':
                    newBounds.maxY = currentY;
                    break;
                case 'se':
                    newBounds.maxX = currentX;
                    newBounds.maxY = currentY;
                    break;
            }
            
            // 최소 크기 제한
            if (newBounds.maxX - newBounds.minX < 10) return;
            if (newBounds.maxY - newBounds.minY < 10) return;
            
            const scaleX = (newBounds.maxX - newBounds.minX) / originalWidth;
            const scaleY = (newBounds.maxY - newBounds.minY) / originalHeight;
            
            if (selectedObject.type === 'brush') {
                // 브러시 스트로크 크기 조정
                selectedObject.points.forEach(point => {
                    const relativeX = (point.x - bounds.minX) / originalWidth;
                    const relativeY = (point.y - bounds.minY) / originalHeight;
                    point.x = newBounds.minX + relativeX * (newBounds.maxX - newBounds.minX);
                    point.y = newBounds.minY + relativeY * (newBounds.maxY - newBounds.minY);
                });
                // 브러시 크기도 스케일에 맞게 조정
                selectedObject.style.size *= Math.min(scaleX, scaleY);
            } else if (selectedObject.type === 'text') {
                // 텍스트 위치와 크기 조정
                const relativeX = (selectedObject.x - bounds.minX) / originalWidth;
                const relativeY = (selectedObject.y - bounds.minY) / originalHeight;
                selectedObject.x = newBounds.minX + relativeX * (newBounds.maxX - newBounds.minX);
                selectedObject.y = newBounds.minY + relativeY * (newBounds.maxY - newBounds.minY);
                
                // 폰트 크기 조정
                selectedObject.style.fontSize *= Math.min(scaleX, scaleY);
                selectedObject.style.font = `${selectedObject.style.fontSize}px Arial`;
            }
            
            selectedObject.bounds = newBounds;
            redrawCanvas();
        }
        
        function handleDoubleClick(e) {
            if (currentTool !== 'select') return;
            
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) / zoomLevel;
            const y = (e.clientY - rect.top) / zoomLevel;
            
            const clickedObject = getObjectAt(x, y);
            if (clickedObject && clickedObject.type === 'text') {
                editTextObject(clickedObject);
            }
        }
        
        function editTextObject(textObj) {
            const textInput = document.getElementById('textInput');
            
            // 기존 텍스트 내용 설정
            textInput.value = textObj.text;
            
            // 텍스트 객체 위치에 입력창 표시
            textInput.style.left = (textObj.x * zoomLevel) + 'px';
            textInput.style.top = ((textObj.y - textObj.style.fontSize) * zoomLevel) + 'px';
            textInput.style.fontSize = (textObj.style.fontSize * zoomLevel) + 'px';
            textInput.style.color = textObj.style.color;
            textInput.style.display = 'block';
            textInput.focus();
            textInput.select();
            
            // 편집 완료 처리
            const finishEdit = () => {
                const newText = textInput.value.trim();
                if (newText) {
                    textObj.text = newText;
                    // 텍스트 경계 업데이트
                    const textWidth = newText.length * textObj.style.fontSize * 0.6;
                    textObj.bounds.maxX = textObj.bounds.minX + textWidth;
                    redrawCanvas();
                }
                textInput.style.display = 'none';
                textInput.value = '';
            };
            
            // 입력창에서 포커스 잃으면 편집 완료
            textInput.onblur = finishEdit;
            
            // Enter 키로 편집 완료
            textInput.onkeydown = function(e) {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    finishEdit();
                }
                if (e.key === 'Escape') {
                    textInput.style.display = 'none';
                    textInput.value = '';
                }
            };
        }
        
        function updateCursorForSelect(x, y) {
            if (selectedObject) {
                const handle = getResizeHandle(x, y);
                if (handle) {
                    // 크기 조정 핸들에 따른 커서 변경
                    switch(handle) {
                        case 'nw':
                        case 'se':
                            canvas.style.cursor = 'nw-resize';
                            break;
                        case 'ne':
                        case 'sw':
                            canvas.style.cursor = 'ne-resize';
                            break;
                        case 'n':
                        case 's':
                            canvas.style.cursor = 'ns-resize';
                            break;
                        case 'w':
                        case 'e':
                            canvas.style.cursor = 'ew-resize';
                            break;
                    }
                } else if (getObjectAt(x, y)) {
                    canvas.style.cursor = 'move';
                } else {
                    canvas.style.cursor = 'default';
                }
            } else {
                const obj = getObjectAt(x, y);
                if (obj) {
                    canvas.style.cursor = 'pointer';
                } else {
                    canvas.style.cursor = 'default';
                }
            }
        }

        function addLayer() {
            const layerName = prompt('새 레이어 이름:', `레이어 ${layers.length + 1}`);
            if (layerName) {
                layers.push({
                    name: layerName,
                    visible: true,
                    canvas: createLayerCanvas()
                });
                updateLayersList();
            }
        }

        function updateLayersList() {
            const layersList = document.getElementById('layers-list');
            layersList.innerHTML = '';
            
            layers.forEach((layer, index) => {
                const layerItem = document.createElement('div');
                layerItem.className = 'layer-item';
                layerItem.dataset.layer = index;
                
                layerItem.innerHTML = `
                    <input type="checkbox" class="layer-visibility" ${layer.visible ? 'checked' : ''}>
                    <span class="layer-name">${layer.name}</span>
                `;
                
                layersList.appendChild(layerItem);
            });
        }

        function clearCanvas() {
            if (confirm('현재 레이어의 모든 객체를 지우시겠습니까?')) {
                // 현재 레이어의 모든 객체 제거
                const objectsToRemove = drawingObjects.filter(obj => obj.layer === currentLayer);
                objectsToRemove.forEach(obj => {
                    const index = drawingObjects.indexOf(obj);
                    if (index > -1) {
                        drawingObjects.splice(index, 1);
                    }
                });
                
                // 선택된 객체가 삭제된 경우 선택 해제
                selectedObject = null;
                selectedObjects = [];
                
                redrawCanvas();
                showStatus(`레이어 '${layers[currentLayer].name}'의 ${objectsToRemove.length}개 객체가 지워졌습니다.`);
            }
        }

        function exportImage() {
            const link = document.createElement('a');
            link.download = 'webtoon.png';
            link.href = canvas.toDataURL();
            link.click();
            showStatus('이미지가 다운로드되었습니다.');
        }

        function zoomIn() {
            zoomLevel = Math.min(zoomLevel * 1.2, 5);
            updateZoom();
        }

        function zoomOut() {
            zoomLevel = Math.max(zoomLevel / 1.2, 0.1);
            updateZoom();
        }

        function updateZoom() {
            const canvasArea = document.getElementById('canvasArea');
            canvasArea.style.transform = `scale(${zoomLevel})`;
            document.getElementById('zoomDisplay').textContent = Math.round(zoomLevel * 100) + '%';
        }

        function handleKeydown(e) {
            if (e.ctrlKey || e.metaKey) {
                switch(e.key) {
                    case 'z':
                        e.preventDefault();
                        // 실행 취소 기능 (추후 구현)
                        break;
                    case 's':
                        e.preventDefault();
                        exportImage();
                        break;
                }
            }
        }

        function showStatus(message) {
            const statusBar = document.getElementById('statusBar');
            statusBar.textContent = message;
            statusBar.style.display = 'block';
            setTimeout(() => {
                statusBar.style.display = 'none';
            }, 3000);
        }

        // AI 챗 기능
        function sendMessage() {
            const input = document.getElementById('chatInput');
            const message = input.value.trim();
            
            if (!message) return;
            
            addChatMessage(message, 'user');
            input.value = '';
            
            // "배경" 단어 감지
            if (message.includes('배경')) {
                addChatMessage('배경 이미지를 추가하겠습니다.', 'ai');
                setTimeout(() => {
                    addBackgroundImage();
                }, 1000);
                return;
            }
            
            if (!selectedArea) {
                addChatMessage('먼저 편집할 영역을 선택해주세요.', 'ai');
                return;
            }
            
            // AI 응답 시뮬레이션
            setTimeout(() => {
                processAIRequest(message);
            }, 1000);
        }

        function addChatMessage(message, sender) {
            const chatMessages = document.getElementById('chatMessages');
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${sender}`;
            messageDiv.textContent = message;
            chatMessages.appendChild(messageDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        function processAIRequest(request) {
            // 실제로는 여기서 AI API 호출
            const responses = [
                '선택된 영역의 이미지 편집을 시작합니다...',
                '웹툰 스타일로 변환 중입니다...',
                '캐릭터 표정을 수정하고 있습니다...',
                '텍스트와 이미지를 조합하여 편집 중입니다...',
                '편집이 완료되었습니다! 결과를 확인해보세요.'
            ];
            
            const response = responses[Math.floor(Math.random() * responses.length)];
            addChatMessage(response, 'ai');
            
            // 가짜 편집 효과
            simulateEdit();
        }

        function simulateEdit() {
            if (!selectedArea) return;
            
            const layerCanvas = layers[currentLayer].canvas;
            const layerCtx = layerCanvas.getContext('2d');
            
            // 선택된 영역에 간단한 효과 적용
            layerCtx.save();
            layerCtx.globalAlpha = 0.3;
            layerCtx.fillStyle = '#ff6b6b';
            layerCtx.fillRect(selectedArea.x, selectedArea.y, selectedArea.width, selectedArea.height);
            layerCtx.restore();
            
            redrawCanvas();
            showStatus('AI 편집이 적용되었습니다!');
        }

        // 드래그 앤 드롭 기능
        function setupDragDrop() {
            canvas.addEventListener('dragover', function(e) {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'copy';
            });

            canvas.addEventListener('drop', function(e) {
                e.preventDefault();
                const files = e.dataTransfer.files;
                
                if (files.length > 0) {
                    const file = files[0];
                    if (file.type.startsWith('image/')) {
                        loadImageToCanvas(file);
                    }
                }
            });
        }

        function loadImageToCanvas(file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    const layerCanvas = layers[currentLayer].canvas;
                    const layerCtx = layerCanvas.getContext('2d');
                    
                    // 이미지를 캔버스 크기에 맞게 조정
                    const scale = Math.min(canvas.width / img.width, canvas.height / img.height);
                    const width = img.width * scale;
                    const height = img.height * scale;
                    const x = (canvas.width - width) / 2;
                    const y = (canvas.height - height) / 2;
                    
                    layerCtx.drawImage(img, x, y, width, height);
                    redrawCanvas();
                    showStatus('이미지가 로드되었습니다.');
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        // 레이어 가시성 토글
        document.addEventListener('change', function(e) {
            if (e.target.classList.contains('layer-visibility')) {
                const layerItem = e.target.closest('.layer-item');
                const layerIndex = parseInt(layerItem.dataset.layer);
                layers[layerIndex].visible = e.target.checked;
                redrawCanvas();
                
                const layerName = layers[layerIndex].name;
                showStatus(`레이어 '${layerName}' ${e.target.checked ? '표시' : '숨김'}`);
            }
        });

        // 고급 브러시 기능
        function setupAdvancedBrush() {
            let lastTime = 0;
            let velocity = 0;
            
            canvas.addEventListener('mousemove', function(e) {
                const currentTime = Date.now();
                const deltaTime = currentTime - lastTime;
                
                if (deltaTime > 0 && isDrawing) {
                    const deltaX = e.movementX || 0;
                    const deltaY = e.movementY || 0;
                    velocity = Math.sqrt(deltaX * deltaX + deltaY * deltaY) / deltaTime;
                    
                    // 속도에 따른 브러시 크기 조정
                    const dynamicSize = Math.max(1, document.getElementById('brushSize').value * (1 - velocity * 0.1));
                    
                    if (currentTool === 'brush') {
                        const layerCanvas = layers[currentLayer].canvas;
                        const layerCtx = layerCanvas.getContext('2d');
                        layerCtx.lineWidth = dynamicSize;
                    }
                }
                
                lastTime = currentTime;
            });
        }



        // 실행 취소/다시 실행 기능
        let history = [];
        let historyStep = -1;

        function saveState() {
            historyStep++;
            if (historyStep < history.length) {
                history.length = historyStep;
            }
            
            const state = layers.map(layer => {
                const canvas = document.createElement('canvas');
                canvas.width = layer.canvas.width;
                canvas.height = layer.canvas.height;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(layer.canvas, 0, 0);
                return {
                    name: layer.name,
                    visible: layer.visible,
                    canvas: canvas
                };
            });
            
            history.push(state);
            
            // 히스토리 크기 제한
            if (history.length > 20) {
                history.shift();
                historyStep--;
            }
        }

        function undo() {
            if (historyStep > 0) {
                historyStep--;
                restoreState(history[historyStep]);
                showStatus('실행 취소');
            }
        }

        function redo() {
            if (historyStep < history.length - 1) {
                historyStep++;
                restoreState(history[historyStep]);
                showStatus('다시 실행');
            }
        }

        function restoreState(state) {
            layers = state.map(layerState => ({
                name: layerState.name,
                visible: layerState.visible,
                canvas: layerState.canvas
            }));
            
            updateLayersList();
            redrawCanvas();
        }

        // 키보드 단축키 업데이트
        function handleKeydown(e) {
            if (e.ctrlKey || e.metaKey) {
                switch(e.key) {
                    case 'z':
                        e.preventDefault();
                        if (e.shiftKey) {
                            redo();
                        } else {
                            undo();
                        }
                        break;
                    case 's':
                        e.preventDefault();
                        exportImage();
                        break;
                    case 'a':
                        e.preventDefault();
                        selectAllArea();
                        break;
                }
            }
            
            // 객체 조작 단축키
            if (e.key === 'Delete' || e.key === 'Backspace') {
                if (selectedObject || selectedObjects.length > 0) {
                    deleteSelectedObjects();
                    e.preventDefault();
                }
            }
            
            // ESC로 선택 해제
            if (e.key === 'Escape') {
                selectedObject = null;
                selectedObjects = [];
                selectedArea = null;
                hideSelectionBox();
                redrawCanvas();
                showStatus('선택 해제됨');
            }
            
            // 도구 단축키
            switch(e.key) {
                case 'v':
                    selectTool('select');
                    break;
                case 'b':
                    selectTool('brush');
                    break;
                case 'e':
                    selectTool('eraser');
                    break;
                case 't':
                    selectTool('text');
                    break;
            }
        }
        
        function deleteSelectedObjects() {
            let deletedCount = 0;
            
            // 단일 선택된 객체 삭제
            if (selectedObject) {
                const index = drawingObjects.indexOf(selectedObject);
                if (index > -1) {
                    drawingObjects.splice(index, 1);
                    deletedCount++;
                }
                selectedObject = null;
            }
            
            // 다중 선택된 객체들 삭제
            if (selectedObjects.length > 0) {
                selectedObjects.forEach(obj => {
                    const index = drawingObjects.indexOf(obj);
                    if (index > -1) {
                        drawingObjects.splice(index, 1);
                        deletedCount++;
                    }
                });
                selectedObjects = [];
            }
            
            if (deletedCount > 0) {
                showStatus(`${deletedCount}개 객체 삭제됨`);
                redrawCanvas();
            }
        }

        function selectAllArea() {
            selectedArea = {
                x: 0,
                y: 0,
                width: canvas.width,
                height: canvas.height
            };
            
            const selectionBox = document.getElementById('selectionBox');
            selectionBox.style.left = '0px';
            selectionBox.style.top = '0px';
            selectionBox.style.width = canvas.width * zoomLevel + 'px';
            selectionBox.style.height = canvas.height * zoomLevel + 'px';
            selectionBox.style.display = 'block';
            
            showStatus('전체 영역이 선택되었습니다.');
        }

        // 초기화 함수들 호출
        setTimeout(() => {
            setupDragDrop();
            setupAdvancedBrush();
            saveState(); // 초기 상태 저장
        }, 100);

        // Enter 키로 채팅 전송
        document.getElementById('chatInput').addEventListener('keydown', function(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        });

        // 캐릭터 레퍼런스 시스템
        function setupCharacterSystem() {
            const uploadArea = document.getElementById('uploadArea');
            const fileInput = document.getElementById('characterFileInput');
            const imagePreview = document.getElementById('imagePreview');

            // 드래그 앤 드롭
            uploadArea.addEventListener('dragover', function(e) {
                e.preventDefault();
                uploadArea.classList.add('dragover');
            });

            uploadArea.addEventListener('dragleave', function(e) {
                e.preventDefault();
                uploadArea.classList.remove('dragover');
            });

            uploadArea.addEventListener('drop', function(e) {
                e.preventDefault();
                uploadArea.classList.remove('dragover');
                const files = e.dataTransfer.files;
                if (files.length > 0 && files[0].type.startsWith('image/')) {
                    handleCharacterImageUpload(files[0]);
                }
            });

            // 클릭 업로드
            uploadArea.addEventListener('click', function() {
                fileInput.click();
            });

            fileInput.addEventListener('change', function(e) {
                if (e.target.files.length > 0) {
                    handleCharacterImageUpload(e.target.files[0]);
                }
            });

            // 캐릭터 갤러리 이벤트
            setupCharacterGalleryEvents();
        }

        function handleCharacterImageUpload(file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                const imagePreview = document.getElementById('imagePreview');
                const uploadContent = document.querySelector('.upload-content');
                
                imagePreview.src = e.target.result;
                imagePreview.style.display = 'block';
                uploadContent.style.display = 'none';
            };
            reader.readAsDataURL(file);
        }

        function addCharacterReference() {
            document.getElementById('characterModal').style.display = 'flex';
            resetCharacterModal();
        }

        function resetCharacterModal() {
            const imagePreview = document.getElementById('imagePreview');
            const uploadContent = document.querySelector('.upload-content');
            const nameInput = document.getElementById('characterNameInput');
            
            imagePreview.style.display = 'none';
            uploadContent.style.display = 'block';
            nameInput.value = '';
            document.getElementById('characterFileInput').value = '';
        }

        function closeCharacterModal() {
            document.getElementById('characterModal').style.display = 'none';
        }

        function saveCharacterReference() {
            const imagePreview = document.getElementById('imagePreview');
            const nameInput = document.getElementById('characterNameInput');
            
            if (!imagePreview.src || imagePreview.style.display === 'none') {
                alert('캐릭터 이미지를 선택해주세요.');
                return;
            }
            
            if (!nameInput.value.trim()) {
                alert('캐릭터 이름을 입력해주세요.');
                return;
            }

            const character = {
                id: Date.now(),
                name: nameInput.value.trim(),
                image: imagePreview.src,
                timestamp: new Date().toISOString()
            };

            characterReferences.push(character);
            updateCharacterGallery();
            closeCharacterModal();
            showStatus(`캐릭터 '${character.name}' 추가됨`);
        }

        function updateCharacterGallery() {
            const gallery = document.getElementById('character-gallery');
            
            // 기존 캐릭터들 표시
            gallery.innerHTML = '';
            
            characterReferences.forEach(character => {
                const slot = document.createElement('div');
                slot.className = 'character-slot';
                slot.style.backgroundImage = `url(${character.image})`;
                slot.dataset.characterId = character.id;
                
                slot.innerHTML = `
                    <div class="character-controls">
                        <button class="delete-character" onclick="deleteCharacter(${character.id})" title="삭제">×</button>
                    </div>
                    <div class="character-info">
                        <div>${character.name}</div>
                    </div>
                `;
                
                slot.addEventListener('click', function(e) {
                    if (!e.target.classList.contains('delete-character')) {
                        selectCharacterReference(character.id);
                    }
                });
                
                // 툴팁 이벤트
                slot.addEventListener('mouseenter', function(e) {
                    showCharacterTooltip(e, character);
                });
                
                slot.addEventListener('mouseleave', function() {
                    hideCharacterTooltip();
                });
                
                gallery.appendChild(slot);
            });
            
            // 새 캐릭터 추가 슬롯
            if (characterReferences.length < 6) { // 최대 6개 제한
                const addSlot = document.createElement('div');
                addSlot.className = 'character-slot empty';
                addSlot.onclick = addCharacterReference;
                addSlot.innerHTML = `
                    <div class="add-character">
                        <span>+</span>
                        <p>캐릭터 추가</p>
                    </div>
                `;
                gallery.appendChild(addSlot);
            }
        }

        function selectCharacterReference(characterId) {
            // 이전 선택 해제
            document.querySelectorAll('.character-slot').forEach(slot => {
                slot.classList.remove('selected');
            });
            
            // 새 선택
            const slot = document.querySelector(`[data-character-id="${characterId}"]`);
            if (slot) {
                slot.classList.add('selected');
                selectedCharacter = characterReferences.find(char => char.id === characterId);
                showStatus(`캐릭터 '${selectedCharacter.name}' 선택됨`);
            }
        }

        function deleteCharacter(characterId) {
            if (confirm('이 캐릭터를 삭제하시겠습니까?')) {
                characterReferences = characterReferences.filter(char => char.id !== characterId);
                if (selectedCharacter && selectedCharacter.id === characterId) {
                    selectedCharacter = null;
                }
                updateCharacterGallery();
                showStatus('캐릭터가 삭제되었습니다.');
            }
        }

        function showCharacterTooltip(event, character) {
            const tooltip = document.getElementById('characterTooltip');
            tooltip.innerHTML = `
                <img src="${character.image}" alt="${character.name}">
                <div><strong>${character.name}</strong></div>
                <div style="color: #aaa; font-size: 10px;">추가일: ${new Date(character.timestamp).toLocaleDateString()}</div>
            `;
            
            const rect = event.target.getBoundingClientRect();
            tooltip.style.left = (rect.right + 10) + 'px';
            tooltip.style.top = rect.top + 'px';
            tooltip.style.display = 'block';
        }

        function hideCharacterTooltip() {
            document.getElementById('characterTooltip').style.display = 'none';
        }

        function setupCharacterGalleryEvents() {
            // 갤러리 외부 클릭시 선택 해제
            document.addEventListener('click', function(e) {
                if (!e.target.closest('#character-gallery')) {
                    document.querySelectorAll('.character-slot').forEach(slot => {
                        slot.classList.remove('selected');
                    });
                    selectedCharacter = null;
                }
            });
        }

        // 레퍼런스로 생성 기능
        function generateWithReference() {
            if (!selectedCharacter) {
                addChatMessage('먼저 캐릭터를 선택해주세요.', 'ai');
                return;
            }
            
            if (!selectedArea) {
                addChatMessage('편집할 영역을 먼저 선택해주세요.', 'ai');
                return;
            }
            
            const message = selectedCharacter ? 
                `선택된 캐릭터 '${selectedCharacter.name}'의 레퍼런스를 Nano Banana를 사용하여 이미지를 생성합니다.` :
                `Nano Banana를 사용하여 이미지를 생성합니다.`;
            addChatMessage(message, 'ai');
            
            // AI 처리 시뮬레이션
            setTimeout(() => {
                const responses = selectedCharacter ? [
                    `${selectedCharacter.name}의 스타일을 분석하고 있습니다...`,
                    '일관된 캐릭터 특징을 적용하여 이미지를 생성 중입니다...',
                    '레퍼런스 기반 웹툰 스타일 변환을 진행합니다...',
                    `${selectedCharacter.name}의 특징을 유지하며 편집이 완료되었습니다!`
                ] : [
                    'Nano Banana AI가 이미지 분석을 시작합니다...',
                    '웹툰 스타일로 이미지를 변환 중입니다...',
                    '고품질 결과물을 생성하고 있습니다...',
                    'Nano Banana AI 편집이 완료되었습니다!'
                ];
                
                responses.forEach((response, index) => {
                    setTimeout(() => {
                        addChatMessage(response, 'ai');
                        if (index === responses.length - 1) {
                            simulateCharacterEdit();
                        }
                    }, (index + 1) * 1500);
                });
            }, 500);
        }

        function simulateCharacterEdit() {
            console.log('simulateCharacterEdit 시작');
            console.log('selectedArea:', selectedArea);
            
            if (!selectedArea) {
                console.log('selectedArea가 없어서 종료');
                return;
            }
            
            const layerCanvas = layers[currentLayer].canvas;
            const layerCtx = layerCanvas.getContext('2d');
            
            console.log('현재 레이어:', currentLayer);
            console.log('layerCanvas 크기:', layerCanvas.width, 'x', layerCanvas.height);
            
            // 지정된 결과 이미지로 편집 시뮬레이션
            const resultImg = new Image();
            resultImg.onload = function() {
                console.log('이미지 로드 완료');
                console.log('이미지 크기:', resultImg.width, 'x', resultImg.height);
                
                // 선택 영역에 맞게 이미지 크기 조정
                const scale = Math.min(selectedArea.width / resultImg.width, selectedArea.height / resultImg.height);
                const width = resultImg.width * scale;
                const height = resultImg.height * scale;
                const x = selectedArea.x + (selectedArea.width - width) / 2;
                const y = selectedArea.y + (selectedArea.height - height) / 2;
                
                console.log('그리기 계산된 값들:', { scale, width, height, x, y });
                
                // 이미지를 객체로 추가 (레이어 캔버스에 직접 그리지 않음)
                const imageObject = {
                    id: objectId++,
                    type: 'image',
                    layer: currentLayer,
                    x: x,
                    y: y,
                    width: width,
                    height: height,
                    image: resultImg,
                    bounds: { minX: x, maxX: x + width, minY: y, maxY: y + height }
                };
                
                drawingObjects.push(imageObject);
                
                console.log('이미지 객체 추가됨, redrawCanvas 호출');
                redrawCanvas();
                showStatus('Nano Banana AI 편집 완료!');
            };
            
            // 이미지 로드 실패 시 기본 효과
            resultImg.onerror = function(error) {
                console.error('이미지 로드 실패:', error);
                console.error('이미지 src:', resultImg.src);
                layerCtx.save();
                layerCtx.globalAlpha = 0.3;
                layerCtx.fillStyle = '#ff6b6b';
                layerCtx.fillRect(selectedArea.x, selectedArea.y, selectedArea.width, selectedArea.height);
                layerCtx.restore();
                redrawCanvas();
                showStatus('결과 이미지를 로드할 수 없어 기본 효과를 적용했습니다.');
            };
            
            resultImg.crossOrigin = 'anonymous'; // CORS 문제 방지
            const imagePath = './character_result.png?t=' + Date.now();
            console.log('이미지 로드 시작:', imagePath);
            resultImg.src = imagePath;
        }

        // 캐릭터 추출 기능
        function extractCharacter() {
            if (!selectedArea) {
                addChatMessage('추출할 영역을 먼저 선택해주세요.', 'ai');
                return;
            }
            
            // 선택된 영역에서 캐릭터 추출
            const extractedData = ctx.getImageData(selectedArea.x, selectedArea.y, selectedArea.width, selectedArea.height);
            
            // 임시 캔버스에 추출된 이미지 그리기
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = selectedArea.width;
            tempCanvas.height = selectedArea.height;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.putImageData(extractedData, 0, 0);
            
            // 추출된 이미지를 캐릭터로 추가할지 확인
            if (confirm('선택된 영역을 새 캐릭터 레퍼런스로 추가하시겠습니까?')) {
                const characterName = prompt('캐릭터 이름을 입력하세요:', '추출된 캐릭터');
                if (characterName) {
                    const character = {
                        id: Date.now(),
                        name: characterName,
                        image: tempCanvas.toDataURL(),
                        timestamp: new Date().toISOString()
                    };
                    
                    characterReferences.push(character);
                    updateCharacterGallery();
                    showStatus(`캐릭터 '${characterName}' 추출 완료!`);
                }
            }
        }

        // AI 메시지 처리 업데이트
        function processAIRequest(request) {
            let responses = [];
            
            if (selectedCharacter) {
                responses = [
                    `'${selectedCharacter.name}' 캐릭터 레퍼런스를 기반으로 편집을 시작합니다...`,
                    '일관된 캐릭터 스타일을 유지하며 이미지를 생성 중입니다...',
                    'Nano Banana 스타일의 웹툰 변환을 적용하고 있습니다...',
                    `${selectedCharacter.name}의 특징을 살린 편집이 완료되었습니다!`
                ];
            } else {
                responses = [
                    '선택된 영역의 이미지 편집을 시작합니다...',
                    '웹툰 스타일로 변환 중입니다...',
                    '편집이 완료되었습니다! 캐릭터 레퍼런스를 추가하시면 더 일관된 결과를 얻을 수 있습니다.'
                ];
            }
            
            responses.forEach((response, index) => {
                setTimeout(() => {
                    addChatMessage(response, 'ai');
                    if (index === responses.length - 1) {
                        if (selectedCharacter) {
                            simulateCharacterEdit();
                        } else {
                            simulateEdit();
                        }
                    }
                }, (index + 1) * 1000);
            });
        }
    </script>
</body>
</html>