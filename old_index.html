<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ì›¹íˆ° AI ì—ë””í„°</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a1a;
            color: #fff;
            height: 100vh;
            overflow: hidden;
        }

        .app-container {
            display: flex;
            height: 100vh;
        }

        /* ì¢Œì¸¡ ë„êµ¬ íŒ¨ë„ */
        .left-panel {
            width: 250px;
            background: #2d2d2d;
            border-right: 1px solid #444;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* íƒ­ í—¤ë” */
        .tab-header {
            display: flex;
            background: #1a1a1a;
            border-bottom: 1px solid #444;
        }

        .tab-button {
            flex: 1;
            padding: 12px 8px;
            background: none;
            border: none;
            color: #aaa;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
            border-bottom: 2px solid transparent;
        }

        .tab-button:hover {
            color: #fff;
            background: #333;
        }

        .tab-button.active {
            color: #0066cc;
            background: #2d2d2d;
            border-bottom-color: #0066cc;
        }

        /* íƒ­ ë‚´ìš© */
        .tab-content {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .tool-section {
            margin-bottom: 30px;
        }

        .tool-section h3 {
            font-size: 14px;
            color: #aaa;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .tool-button {
            display: block;
            width: 100%;
            padding: 12px;
            margin-bottom: 8px;
            background: #3a3a3a;
            border: none;
            border-radius: 8px;
            color: #fff;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 13px;
        }

        .tool-button:hover {
            background: #4a4a4a;
            transform: translateY(-1px);
        }

        .tool-button.active {
            background: #0066cc;
        }

        .shortcut {
            float: right;
            font-size: 11px;
            color: #aaa;
            font-weight: normal;
            background: rgba(255, 255, 255, 0.1);
            padding: 2px 6px;
            border-radius: 3px;
            margin-left: 8px;
        }

        .tool-button:hover .shortcut {
            color: #fff;
            background: rgba(255, 255, 255, 0.2);
        }

        .tool-button.active .shortcut {
            color: #fff;
            background: rgba(255, 255, 255, 0.2);
        }

        /* ë‹¨ì¶•í‚¤ ê°€ì´ë“œ */
        .shortcut-guide {
            font-size: 11px;
        }

        .shortcut-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
            padding: 4px 0;
        }

        .key {
            background: #4a4a4a;
            color: #fff;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: monospace;
            font-size: 10px;
            font-weight: bold;
            min-width: 30px;
            text-align: center;
            border: 1px solid #666;
        }

        .action {
            color: #ccc;
            font-size: 10px;
            flex: 1;
            margin-left: 8px;
        }

        .layer-item {
            display: flex;
            align-items: center;
            padding: 8px 12px;
            margin-bottom: 4px;
            background: #3a3a3a;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .layer-item:hover {
            background: #4a4a4a;
        }

        .layer-item.selected {
            background: #0066cc;
        }

        .layer-visibility {
            width: 16px;
            height: 16px;
            margin-right: 8px;
            cursor: pointer;
        }

        .layer-name {
            flex: 1;
            font-size: 12px;
        }

        .add-layer-btn {
            width: 100%;
            padding: 8px;
            background: #444;
            border: 2px dashed #666;
            border-radius: 6px;
            color: #aaa;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }

        .add-layer-btn:hover {
            border-color: #888;
            color: #fff;
        }

        /* ì¤‘ì•™ ìº”ë²„ìŠ¤ ì˜ì—­ */
        .canvas-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #1a1a1a;
            position: relative;
        }

        .canvas-toolbar {
            height: 50px;
            background: #2d2d2d;
            border-bottom: 1px solid #444;
            display: flex;
            align-items: center;
            padding: 0 20px;
            gap: 15px;
        }

        .zoom-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .zoom-btn {
            width: 30px;
            height: 30px;
            background: #444;
            border: none;
            border-radius: 4px;
            color: #fff;
            cursor: pointer;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .zoom-btn:hover {
            background: #555;
        }

        .zoom-display {
            min-width: 60px;
            text-align: center;
            font-size: 12px;
            color: #aaa;
        }

        .canvas-wrapper {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background: 
                radial-gradient(circle, #333 1px, transparent 1px),
                radial-gradient(circle, #333 1px, transparent 1px);
            background-size: 20px 20px;
            background-position: 0 0, 10px 10px;
        }

        .canvas-area {
            position: relative;
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            overflow: hidden;
        }

        #main-canvas {
            display: block;
            cursor: crosshair;
        }

        .selection-box {
            position: absolute;
            border: 2px dashed #0066cc;
            background: rgba(0, 102, 204, 0.1);
            pointer-events: none;
            display: none;
        }

        /* ìš°ì¸¡ AI ì±— íŒ¨ë„ */
        .right-panel {
            width: 300px;
            background: #2d2d2d;
            border-left: 1px solid #444;
            display: flex;
            flex-direction: column;
        }

        .chat-header {
            height: 60px;
            background: #363636;
            display: flex;
            align-items: center;
            padding: 0 20px;
            border-bottom: 1px solid #444;
        }

        .chat-header h2 {
            font-size: 16px;
            font-weight: 600;
        }

        .chat-messages {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .message {
            max-width: 85%;
            padding: 12px 16px;
            border-radius: 18px;
            font-size: 14px;
            line-height: 1.4;
        }

        .message.user {
            background: #0066cc;
            color: #fff;
            align-self: flex-end;
            margin-left: auto;
        }

        .message.ai {
            background: #3a3a3a;
            color: #fff;
            align-self: flex-start;
        }

        .chat-input-area {
            padding: 20px;
            border-top: 1px solid #444;
        }

        .chat-input {
            width: 100%;
            padding: 12px 16px;
            background: #3a3a3a;
            border: 1px solid #555;
            border-radius: 8px;
            color: #fff;
            font-size: 14px;
            resize: none;
            outline: none;
            min-height: 80px;
        }

        .chat-input:focus {
            border-color: #0066cc;
        }

        .send-button {
            width: 100%;
            padding: 10px;
            margin-top: 10px;
            background: #0066cc;
            border: none;
            border-radius: 6px;
            color: #fff;
            font-size: 14px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .send-button:hover {
            background: #0077dd;
        }

        .send-button:disabled {
            background: #555;
            cursor: not-allowed;
        }

        /* ë¸ŒëŸ¬ì‹œ ì„¤ì • */
        .brush-settings {
            margin-top: 15px;
        }

        .setting-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .setting-row label {
            font-size: 12px;
            color: #aaa;
        }

        .setting-row input[type="range"] {
            width: 60px;
        }

        .color-picker {
            width: 30px;
            height: 30px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        /* í…ìŠ¤íŠ¸ ë„êµ¬ */
        .text-input {
            position: absolute;
            background: transparent;
            border: 2px dashed #0066cc;
            color: #333;
            font-family: Arial, sans-serif;
            outline: none;
            resize: none;
            display: none;
            min-width: 100px;
            min-height: 30px;
            padding: 5px;
        }

        /* ìƒíƒœ í‘œì‹œ */
        .status-bar {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: #fff;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            display: none;
        }

        /* ìºë¦­í„° ë ˆí¼ëŸ°ìŠ¤ ì‹œìŠ¤í…œ */
        .character-slot {
            width: 80px;
            height: 80px;
            background: #3a3a3a;
            border: 2px dashed #666;
            border-radius: 8px;
            margin-bottom: 10px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            background-size: cover;
            background-position: center;
            position: relative;
            transition: all 0.2s;
        }

        .character-slot:hover {
            border-color: #0066cc;
            transform: translateY(-2px);
        }

        .character-slot.selected {
            border-color: #0066cc;
            box-shadow: 0 0 10px rgba(0, 102, 204, 0.3);
        }

        .character-slot.empty {
            background: #2a2a2a;
        }

        .add-character {
            text-align: center;
            color: #666;
        }

        .add-character span {
            font-size: 24px;
            display: block;
            margin-bottom: 5px;
        }

        .add-character p {
            font-size: 10px;
            margin: 0;
        }

        .character-controls {
            position: absolute;
            top: 5px;
            right: 5px;
        }

        .delete-character {
            background: rgba(255, 0, 0, 0.8);
            color: white;
            border: none;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            font-size: 12px;
            cursor: pointer;
            display: none;
        }

        .character-slot:hover .delete-character {
            display: block;
        }

        .character-info {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 3px;
            font-size: 10px;
            text-align: center;
            border-radius: 0 0 6px 6px;
        }

        /* ìºë¦­í„° ëª¨ë‹¬ */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .modal-content {
            background: #2d2d2d;
            border-radius: 10px;
            padding: 20px;
            width: 400px;
            max-width: 90vw;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .modal-title {
            color: #fff;
            font-size: 18px;
            margin: 0;
        }

        .close-modal {
            background: none;
            border: none;
            color: #aaa;
            font-size: 24px;
            cursor: pointer;
        }

        .close-modal:hover {
            color: #fff;
        }

        .upload-area {
            border: 2px dashed #666;
            border-radius: 8px;
            padding: 40px 20px;
            text-align: center;
            margin-bottom: 20px;
            cursor: pointer;
            transition: border-color 0.2s;
        }

        .upload-area:hover {
            border-color: #0066cc;
        }

        .upload-area.dragover {
            border-color: #0066cc;
            background: rgba(0, 102, 204, 0.1);
        }

        .upload-content {
            color: #aaa;
        }

        .upload-icon {
            font-size: 48px;
            margin-bottom: 10px;
        }

        #imagePreview {
            max-width: 100%;
            max-height: 200px;
            border-radius: 8px;
            display: none;
        }

        .character-name-input {
            width: 100%;
            padding: 10px;
            background: #3a3a3a;
            border: 1px solid #555;
            border-radius: 6px;
            color: #fff;
            margin-bottom: 20px;
        }

        .modal-buttons {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }

        .modal-button {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
        }

        .modal-button.primary {
            background: #0066cc;
            color: white;
        }

        .modal-button.secondary {
            background: #666;
            color: white;
        }

        .modal-button:hover {
            opacity: 0.8;
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- ì¢Œì¸¡ ë„êµ¬ íŒ¨ë„ -->
        <div class="left-panel">
            <!-- íƒ­ í—¤ë” -->
            <div class="tab-header">
                <button class="tab-button active" data-tab="tools">ğŸ› ï¸ ë„êµ¬</button>
                <button class="tab-button" data-tab="characters">ğŸ­ ìºë¦­í„°</button>
            </div>

            <!-- ë„êµ¬ íƒ­ -->
            <div class="tab-content active" data-tab-content="tools">
                <div class="tool-section">
                    <h3>ë„êµ¬</h3>
                    <button class="tool-button active" data-tool="select">ğŸ“ ì„ íƒ ë„êµ¬ <span class="shortcut">V</span></button>
                    <button class="tool-button" data-tool="brush">ğŸ–Œï¸ ë¸ŒëŸ¬ì‹œ <span class="shortcut">B</span></button>
                    <button class="tool-button" data-tool="eraser">ğŸ§¹ ì§€ìš°ê°œ <span class="shortcut">E</span></button>
                    <button class="tool-button" data-tool="text">ğŸ“ í…ìŠ¤íŠ¸ <span class="shortcut">T</span></button>
                    <button class="tool-button" data-tool="shape">â­• ë„í˜•</button>
                </div>

                <div class="tool-section">
                    <h3>ë¸ŒëŸ¬ì‹œ ì„¤ì •</h3>
                    <div class="brush-settings">
                        <div class="setting-row">
                            <label>í¬ê¸°:</label>
                            <input type="range" id="brushSize" min="1" max="50" value="5">
                            <span id="sizeValue">5</span>
                        </div>
                        <div class="setting-row">
                            <label>ìƒ‰ìƒ:</label>
                            <input type="color" id="brushColor" class="color-picker" value="#000000">
                        </div>
                        <div class="setting-row">
                            <label>íˆ¬ëª…ë„:</label>
                            <input type="range" id="brushOpacity" min="0" max="100" value="100">
                            <span id="opacityValue">100%</span>
                        </div>
                    </div>
                </div>

                <div class="tool-section">
                    <h3>ë ˆì´ì–´</h3>
                    <div id="layers-list">
                        <div class="layer-item selected" data-layer="0">
                            <input type="checkbox" class="layer-visibility" checked>
                            <span class="layer-name">ë°°ê²½</span>
                        </div>
                        <div class="layer-item" data-layer="1">
                            <input type="checkbox" class="layer-visibility" checked>
                            <span class="layer-name">ìºë¦­í„°</span>
                        </div>
                        <div class="layer-item" data-layer="2">
                            <input type="checkbox" class="layer-visibility" checked>
                            <span class="layer-name">ëŒ€ì‚¬</span>
                        </div>
                    </div>
                    <div class="add-layer-btn" onclick="addLayer()">+ ìƒˆ ë ˆì´ì–´ ì¶”ê°€</div>
                </div>

                <div class="tool-section">
                    <h3>ë‹¨ì¶•í‚¤</h3>
                    <div class="shortcut-guide">
                        <div class="shortcut-item">
                            <span class="key">Del</span>
                            <span class="action">ì„ íƒëœ ê°ì²´ ì‚­ì œ</span>
                        </div>
                        <div class="shortcut-item">
                            <span class="key">Esc</span>
                            <span class="action">ì„ íƒ í•´ì œ</span>
                        </div>
                        <div class="shortcut-item">
                            <span class="key">Ctrl+Z</span>
                            <span class="action">ì‹¤í–‰ ì·¨ì†Œ</span>
                        </div>
                        <div class="shortcut-item">
                            <span class="key">Ctrl+Shift+Z</span>
                            <span class="action">ë‹¤ì‹œ ì‹¤í–‰</span>
                        </div>
                        <div class="shortcut-item">
                            <span class="key">Ctrl+A</span>
                            <span class="action">ì „ì²´ ì„ íƒ</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- ìºë¦­í„° íƒ­ -->
            <div class="tab-content" data-tab-content="characters">
                <div class="tool-section">
                    <h3>ìºë¦­í„° ë ˆí¼ëŸ°ìŠ¤</h3>
                    <div id="character-gallery">
                        <div class="character-slot empty" onclick="addCharacterReference()">
                            <div class="add-character">
                                <span>+</span>
                                <p>ìºë¦­í„° ì¶”ê°€</p>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="tool-section">
                    <h3>ì•¡ì…˜</h3>
                    <div class="reference-controls">
                        <button class="tool-button" onclick="generateWithReference()">ğŸ­ ë ˆí¼ëŸ°ìŠ¤ë¡œ ìƒì„±</button>
                        <button class="tool-button" onclick="extractCharacter()">âœ‚ï¸ ìºë¦­í„° ì¶”ì¶œ</button>
                    </div>
                </div>

                <div class="tool-section">
                    <h3>ì‚¬ìš©ë²•</h3>
                    <div class="usage-guide" style="font-size: 11px; color: #aaa; line-height: 1.4;">
                        <p style="margin-bottom: 8px;">1. ìºë¦­í„° ì´ë¯¸ì§€ë¥¼ ì—…ë¡œë“œí•©ë‹ˆë‹¤</p>
                        <p style="margin-bottom: 8px;">2. ìºë¦­í„°ë¥¼ í´ë¦­í•˜ì—¬ ì„ íƒí•©ë‹ˆë‹¤</p>
                        <p style="margin-bottom: 8px;">3. ìº”ë²„ìŠ¤ì—ì„œ ì˜ì—­ì„ ì„ íƒí•©ë‹ˆë‹¤</p>
                        <p style="margin-bottom: 8px;">4. 'ë ˆí¼ëŸ°ìŠ¤ë¡œ ìƒì„±' í´ë¦­í•©ë‹ˆë‹¤</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- ì¤‘ì•™ ìº”ë²„ìŠ¤ ì˜ì—­ -->
        <div class="canvas-container">
            <div class="canvas-toolbar">
                <div class="zoom-control">
                    <button class="zoom-btn" onclick="zoomOut()">-</button>
                    <span class="zoom-display" id="zoomDisplay">100%</span>
                    <button class="zoom-btn" onclick="zoomIn()">+</button>
                </div>
                <button class="tool-button" onclick="clearCanvas()">ğŸ—‘ï¸ ì „ì²´ ì§€ìš°ê¸°</button>
                <button class="tool-button" onclick="exportImage()">ğŸ’¾ ë‚´ë³´ë‚´ê¸° <span class="shortcut">Ctrl+S</span></button>
            </div>

            <div class="canvas-wrapper">
                <div class="canvas-area" id="canvasArea">
                    <canvas id="main-canvas" width="800" height="600"></canvas>
                    <div class="selection-box" id="selectionBox"></div>
                    <textarea class="text-input" id="textInput"></textarea>
                </div>
            </div>
            
            <div class="status-bar" id="statusBar">ì¤€ë¹„</div>
        </div>

        <!-- ìš°ì¸¡ AI ì±— íŒ¨ë„ -->
        <div class="right-panel">
            <div class="chat-header">
                <h2>ğŸ¤– AI ì–´ì‹œìŠ¤í„´íŠ¸</h2>
            </div>
            
            <div class="chat-messages" id="chatMessages">
                <div class="message ai">
                    ì•ˆë…•í•˜ì„¸ìš”! ì›¹íˆ° ì œì‘ì„ ë„ì™€ë“œë¦´ê²Œìš”. ğŸ¨<br>
                    <br>
                    ë‹¤ìŒê³¼ ê°™ì€ ê¸°ëŠ¥ì„ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:<br>
                    â€¢ ì„ íƒëœ ì˜ì—­ì˜ ì´ë¯¸ì§€ í¸ì§‘<br>
                    â€¢ í…ìŠ¤íŠ¸ì™€ ì´ë¯¸ì§€ ì¡°í•© í¸ì§‘<br>
                    â€¢ ì›¹íˆ° ìŠ¤íƒ€ì¼ ë³€í™˜<br>
                    â€¢ ìºë¦­í„° ì¼ê´€ì„± ìœ ì§€<br>
                    <br>
                    ì˜ì—­ì„ ì„ íƒí•˜ê³  í¸ì§‘ ìš”ì²­ì„ í•´ì£¼ì„¸ìš”!
                </div>
            </div>

            <div class="chat-input-area">
                <textarea id="chatInput" class="chat-input" placeholder="ì—¬ê¸°ì— í¸ì§‘ ìš”ì²­ì„ ì…ë ¥í•˜ì„¸ìš”... ì˜ˆ: 'ì´ ìºë¦­í„°ì˜ í‘œì •ì„ í™”ë‚œ í‘œì •ìœ¼ë¡œ ë°”ê¿”ì£¼ì„¸ìš”'"></textarea>
                <button class="send-button" onclick="sendMessage()">í¸ì§‘ ìš”ì²­ ë³´ë‚´ê¸°</button>
            </div>
        </div>
    </div>

    <!-- ìºë¦­í„° ì¶”ê°€ ëª¨ë‹¬ -->
    <div id="characterModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">ìºë¦­í„° ì¶”ê°€</h2>
                <button class="close-modal" onclick="closeCharacterModal()">&times;</button>
            </div>
            
            <div id="uploadArea" class="upload-area">
                <div class="upload-content">
                    <div class="upload-icon">ğŸ“</div>
                    <p>ì´ë¯¸ì§€ë¥¼ ë“œë˜ê·¸í•˜ê±°ë‚˜ í´ë¦­í•˜ì—¬ ì—…ë¡œë“œ</p>
                    <p style="font-size: 12px; color: #666;">PNG, JPG ì§€ì›</p>
                </div>
                <img id="imagePreview" alt="ë¯¸ë¦¬ë³´ê¸°">
            </div>
            
            <input type="file" id="characterFileInput" accept="image/*" style="display: none;">
            
            <input type="text" id="characterNameInput" class="character-name-input" placeholder="ìºë¦­í„° ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”">
            
            <div class="modal-buttons">
                <button class="modal-button secondary" onclick="closeCharacterModal()">ì·¨ì†Œ</button>
                <button class="modal-button primary" onclick="saveCharacterReference()">ì €ì¥</button>
            </div>
        </div>
    </div>

    <!-- ìºë¦­í„° íˆ´íŒ -->
    <div id="characterTooltip" style="position: absolute; background: #2d2d2d; border: 1px solid #555; border-radius: 6px; padding: 10px; display: none; z-index: 1001; max-width: 200px;">
    </div>

    <script>
        // ì „ì—­ ë³€ìˆ˜
        let canvas, ctx;
        let currentTool = 'select';
        let isDrawing = false;
        let isSelecting = false;
        let startX, startY, endX, endY;
        let layers = [];
        let currentLayer = 0;
        let zoomLevel = 1;
        let selectedArea = null;
        
        // ê°ì²´ ê´€ë¦¬
        let drawingObjects = []; // ëª¨ë“  ê·¸ë¦° ê°ì²´ë“¤ ì €ì¥
        let selectedObject = null;
        let selectedObjects = []; // ë‹¤ì¤‘ ì„ íƒëœ ê°ì²´ë“¤
        let objectId = 0;
        let currentStroke = null;
        
        // ê°ì²´ ì¡°ì‘ ìƒíƒœ
        let isDragging = false;
        let isResizing = false;
        let dragStartX, dragStartY;
        let currentHandle = null; // í˜„ì¬ ì„ íƒëœ í¬ê¸°ì¡°ì • í•¸ë“¤
        
        // ìºë¦­í„° ë ˆí¼ëŸ°ìŠ¤ ì‹œìŠ¤í…œ
        let characterReferences = [];
        let selectedCharacter = null;

        // ì´ˆê¸°í™”
        window.onload = function() {
            canvas = document.getElementById('main-canvas');
            ctx = canvas.getContext('2d');
            
            // ë ˆì´ì–´ ì´ˆê¸°í™”
            initLayers();
            
            // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì„¤ì •
            setupEventListeners();
            
            // ë¸ŒëŸ¬ì‹œ ì„¤ì • ì´ë²¤íŠ¸
            setupBrushControls();
            
            // ìºë¦­í„° ì‹œìŠ¤í…œ ì´ˆê¸°í™”
            setupCharacterSystem();
            updateCharacterGallery();
            
            showStatus('ì›¹íˆ° ì—ë””í„°ê°€ ì¤€ë¹„ë˜ì—ˆìŠµë‹ˆë‹¤!');
        };

        function initLayers() {
            layers = [
                { name: 'ë°°ê²½', visible: true, canvas: createLayerCanvas() },
                { name: 'ìºë¦­í„°', visible: true, canvas: createLayerCanvas() },
                { name: 'ëŒ€ì‚¬', visible: true, canvas: createLayerCanvas() }
            ];
        }

        function createLayerCanvas() {
            const layerCanvas = document.createElement('canvas');
            layerCanvas.width = canvas.width;
            layerCanvas.height = canvas.height;
            return layerCanvas;
        }

        function setupEventListeners() {
            // ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('dblclick', handleDoubleClick);
            
            // ë„êµ¬ ì„ íƒ
            document.querySelectorAll('.tool-button[data-tool]').forEach(btn => {
                btn.addEventListener('click', function() {
                    selectTool(this.dataset.tool);
                });
            });

            // ë ˆì´ì–´ ì„ íƒ
            document.addEventListener('click', function(e) {
                if (e.target.closest('.layer-item')) {
                    selectLayer(e.target.closest('.layer-item').dataset.layer);
                }
            });

            // í‚¤ë³´ë“œ ë‹¨ì¶•í‚¤
            document.addEventListener('keydown', handleKeydown);
            
            // íƒ­ ì „í™˜
            setupTabs();
        }

        function setupTabs() {
            // íƒ­ ë²„íŠ¼ í´ë¦­ ì´ë²¤íŠ¸
            document.querySelectorAll('.tab-button').forEach(button => {
                button.addEventListener('click', function() {
                    const tabName = this.dataset.tab;
                    switchTab(tabName);
                });
            });
        }

        function switchTab(tabName) {
            // ëª¨ë“  íƒ­ ë²„íŠ¼ ë¹„í™œì„±í™”
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // ëª¨ë“  íƒ­ ë‚´ìš© ìˆ¨ê¸°ê¸°
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            
            // ì„ íƒëœ íƒ­ í™œì„±í™”
            document.querySelector(`[data-tab="${tabName}"]`).classList.add('active');
            document.querySelector(`[data-tab-content="${tabName}"]`).classList.add('active');
        }

        function setupBrushControls() {
            const brushSize = document.getElementById('brushSize');
            const sizeValue = document.getElementById('sizeValue');
            const brushOpacity = document.getElementById('brushOpacity');
            const opacityValue = document.getElementById('opacityValue');

            brushSize.addEventListener('input', function() {
                sizeValue.textContent = this.value;
            });

            brushOpacity.addEventListener('input', function() {
                opacityValue.textContent = this.value + '%';
            });
        }

        function selectTool(tool) {
            currentTool = tool;
            document.querySelectorAll('.tool-button[data-tool]').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelector(`[data-tool="${tool}"]`).classList.add('active');
            
            // ì»¤ì„œ ë³€ê²½
            switch(tool) {
                case 'select':
                    canvas.style.cursor = 'default';
                    break;
                case 'brush':
                    canvas.style.cursor = 'crosshair';
                    break;
                case 'eraser':
                    canvas.style.cursor = 'grab';
                    break;
                case 'text':
                    canvas.style.cursor = 'text';
                    break;
            }
            
            showStatus(`${tool} ë„êµ¬ê°€ ì„ íƒë˜ì—ˆìŠµë‹ˆë‹¤.`);
        }

        function selectLayer(layerIndex) {
            currentLayer = parseInt(layerIndex);
            document.querySelectorAll('.layer-item').forEach(item => {
                item.classList.remove('selected');
            });
            document.querySelector(`[data-layer="${layerIndex}"]`).classList.add('selected');
            
            showStatus(`ë ˆì´ì–´ '${layers[currentLayer].name}' ì„ íƒë¨`);
        }

        function handleMouseDown(e) {
            const rect = canvas.getBoundingClientRect();
            startX = (e.clientX - rect.left) / zoomLevel;
            startY = (e.clientY - rect.top) / zoomLevel;

            switch(currentTool) {
                case 'select':
                    // í¬ê¸° ì¡°ì • í•¸ë“¤ í™•ì¸
                    currentHandle = getResizeHandle(startX, startY);
                    if (currentHandle && selectedObject) {
                        isResizing = true;
                        dragStartX = startX;
                        dragStartY = startY;
                    } else {
                        // í´ë¦­ ìœ„ì¹˜ì— ê°ì²´ê°€ ìˆëŠ”ì§€ í™•ì¸
                        const clickedObject = getObjectAt(startX, startY);
                        if (clickedObject) {
                            selectObject(clickedObject);
                            // ì„ íƒëœ ê°ì²´ì—ì„œ ë“œë˜ê·¸ ì‹œì‘
                            isDragging = true;
                            dragStartX = startX;
                            dragStartY = startY;
                        } else {
                            // ê°ì²´ê°€ ì—†ìœ¼ë©´ ì˜ì—­ ì„ íƒ ëª¨ë“œ
                            selectedObject = null;
                            selectedObjects = [];
                            isSelecting = true;
                            hideSelectionBox();
                            redrawCanvas();
                        }
                    }
                    break;
                case 'brush':
                    isDrawing = true;
                    drawBrush(startX, startY);
                    break;
                case 'eraser':
                    isDrawing = true;
                    erase(startX, startY);
                    break;
                case 'text':
                    addTextInput(startX, startY);
                    break;
            }
        }

        function handleMouseMove(e) {
            const rect = canvas.getBoundingClientRect();
            const currentX = (e.clientX - rect.left) / zoomLevel;
            const currentY = (e.clientY - rect.top) / zoomLevel;

            if (isSelecting && currentTool === 'select') {
                updateSelectionBox(startX, startY, currentX, currentY);
            } else if (isDragging && currentTool === 'select') {
                // ê°ì²´ ì´ë™
                const deltaX = currentX - dragStartX;
                const deltaY = currentY - dragStartY;
                moveSelectedObject(deltaX, deltaY);
                dragStartX = currentX;
                dragStartY = currentY;
            } else if (isResizing && currentTool === 'select') {
                // ê°ì²´ í¬ê¸° ì¡°ì •
                resizeSelectedObject(currentX, currentY);
            } else if (isDrawing && currentTool === 'brush') {
                // ì—°ì†ì ì¸ ë¸ŒëŸ¬ì‹œ ìŠ¤íŠ¸ë¡œí¬
                drawBrush(currentX, currentY);
            } else if (isDrawing && currentTool === 'eraser') {
                erase(currentX, currentY);
            } else if (currentTool === 'select' && !isSelecting && !isDragging && !isResizing) {
                // ì»¤ì„œ ìŠ¤íƒ€ì¼ ì—…ë°ì´íŠ¸
                updateCursorForSelect(currentX, currentY);
            }
        }

        function handleMouseUp(e) {
            const rect = canvas.getBoundingClientRect();
            endX = (e.clientX - rect.left) / zoomLevel;
            endY = (e.clientY - rect.top) / zoomLevel;

            if (isSelecting && currentTool === 'select') {
                finalizeSelection();
                isSelecting = false;
            }
            
            if (isDragging) {
                isDragging = false;
            }
            
            if (isResizing) {
                isResizing = false;
                currentHandle = null;
            }
            
            if (isDrawing) {
                // ìŠ¤íŠ¸ë¡œí¬ ì™„ë£Œ
                currentStroke = null;
                isDrawing = false;
            }
        }

        function updateSelectionBox(x1, y1, x2, y2) {
            const selectionBox = document.getElementById('selectionBox');
            const left = Math.min(x1, x2) * zoomLevel;
            const top = Math.min(y1, y2) * zoomLevel;
            const width = Math.abs(x2 - x1) * zoomLevel;
            const height = Math.abs(y2 - y1) * zoomLevel;

            selectionBox.style.left = left + 'px';
            selectionBox.style.top = top + 'px';
            selectionBox.style.width = width + 'px';
            selectionBox.style.height = height + 'px';
            selectionBox.style.display = 'block';
        }

        function finalizeSelection() {
            const selectionRect = {
                x: Math.min(startX, endX),
                y: Math.min(startY, endY),
                width: Math.abs(endX - startX),
                height: Math.abs(endY - startY)
            };
            
            // ì„ íƒ ì˜ì—­ ë‚´ì— ìˆëŠ” ê°ì²´ë“¤ ì°¾ê¸°
            selectedObjects = [];
            drawingObjects.forEach(obj => {
                if (obj.layer === currentLayer && layers[obj.layer].visible && 
                    isObjectInSelectionRect(obj, selectionRect)) {
                    selectedObjects.push(obj);
                }
            });
            
            if (selectedObjects.length > 0) {
                selectedObject = null; // ë‹¨ì¼ ì„ íƒ í•´ì œ
                showStatus(`${selectedObjects.length}ê°œ ê°ì²´ ì„ íƒë¨`);
            } else {
                selectedArea = selectionRect;
                showStatus(`ì˜ì—­ ì„ íƒë¨: ${Math.round(selectionRect.width)}x${Math.round(selectionRect.height)}`);
            }
        }
        
        function isObjectInSelectionRect(obj, rect) {
            // ê°ì²´ì˜ ê²½ê³„ ë°•ìŠ¤ê°€ ì„ íƒ ì˜ì—­ê³¼ ê²¹ì¹˜ëŠ”ì§€ í™•ì¸
            return !(obj.bounds.maxX < rect.x || 
                     obj.bounds.minX > rect.x + rect.width ||
                     obj.bounds.maxY < rect.y || 
                     obj.bounds.minY > rect.y + rect.height);
        }

        function hideSelectionBox() {
            document.getElementById('selectionBox').style.display = 'none';
        }

        function drawBrush(x, y) {
            const brushSize = document.getElementById('brushSize').value;
            const brushColor = document.getElementById('brushColor').value;
            const brushOpacity = document.getElementById('brushOpacity').value / 100;

            // ìƒˆë¡œìš´ ìŠ¤íŠ¸ë¡œí¬ ì‹œì‘
            if (!isDrawing || !currentStroke) {
                currentStroke = {
                    id: objectId++,
                    type: 'brush',
                    layer: currentLayer,
                    points: [{x: x, y: y}],
                    style: {
                        color: brushColor,
                        size: brushSize,
                        opacity: brushOpacity,
                        lineCap: 'round',
                        lineJoin: 'round'
                    },
                    bounds: {
                        minX: x, maxX: x,
                        minY: y, maxY: y
                    }
                };
                drawingObjects.push(currentStroke);
            } else {
                // ê¸°ì¡´ ìŠ¤íŠ¸ë¡œí¬ì— ì  ì¶”ê°€
                currentStroke.points.push({x: x, y: y});
                // ê²½ê³„ ì—…ë°ì´íŠ¸
                currentStroke.bounds.minX = Math.min(currentStroke.bounds.minX, x);
                currentStroke.bounds.maxX = Math.max(currentStroke.bounds.maxX, x);
                currentStroke.bounds.minY = Math.min(currentStroke.bounds.minY, y);
                currentStroke.bounds.maxY = Math.max(currentStroke.bounds.maxY, y);
            }
            
            redrawCanvas();
        }

        function erase(x, y) {
            const brushSize = parseInt(document.getElementById('brushSize').value);
            const eraseRadius = brushSize / 2;
            
            // ì§€ìš°ê°œ ë²”ìœ„ ë‚´ì— ìˆëŠ” ê°ì²´ë“¤ ì°¾ê¸°
            const objectsToRemove = [];
            
            drawingObjects.forEach(obj => {
                if (obj.layer === currentLayer && isObjectInEraseArea(obj, x, y, eraseRadius)) {
                    objectsToRemove.push(obj);
                }
            });
            
            // ì°¾ì€ ê°ì²´ë“¤ ì‚­ì œ
            objectsToRemove.forEach(obj => {
                const index = drawingObjects.indexOf(obj);
                if (index > -1) {
                    drawingObjects.splice(index, 1);
                    if (selectedObject === obj) {
                        selectedObject = null;
                    }
                    // ë‹¤ì¤‘ ì„ íƒì—ì„œë„ ì œê±°
                    const selectedIndex = selectedObjects.indexOf(obj);
                    if (selectedIndex > -1) {
                        selectedObjects.splice(selectedIndex, 1);
                    }
                }
            });
            
            if (objectsToRemove.length > 0) {
                showStatus(`${objectsToRemove.length}ê°œ ê°ì²´ ì§€ì›€`);
                redrawCanvas();
            }
        }
        
        function isObjectInEraseArea(obj, eraseX, eraseY, eraseRadius) {
            if (obj.type === 'brush') {
                // ë¸ŒëŸ¬ì‹œ ìŠ¤íŠ¸ë¡œí¬ì˜ ëª¨ë“  ì ì´ ì§€ìš°ê°œ ë²”ìœ„ ë‚´ì— ìˆëŠ”ì§€ í™•ì¸
                for (let i = 0; i < obj.points.length; i++) {
                    const point = obj.points[i];
                    const distance = Math.sqrt((point.x - eraseX) ** 2 + (point.y - eraseY) ** 2);
                    if (distance <= eraseRadius + obj.style.size / 2) {
                        return true;
                    }
                }
            }
            return false;
        }

        function addTextInput(x, y) {
            const textInput = document.getElementById('textInput');
            textInput.style.left = (x * zoomLevel) + 'px';
            textInput.style.top = (y * zoomLevel) + 'px';
            textInput.style.display = 'block';
            textInput.value = ''; // ê¸°ì¡´ ê°’ í´ë¦¬ì–´
            
            // ì§€ì—° í›„ í¬ì»¤ìŠ¤ (DOM ì—…ë°ì´íŠ¸ ëŒ€ê¸°)
            setTimeout(() => {
                textInput.focus();
            }, 10);
            
            // ì™„ë£Œ ì²˜ë¦¬ í•¨ìˆ˜
            const finishTextInput = () => {
                const text = textInput.value.trim();
                if (text) {
                    addTextToCanvas(x, y, text);
                }
                textInput.style.display = 'none';
                textInput.value = '';
                textInput.onblur = null;
                textInput.onkeydown = null;
            };
            
            // Enter í‚¤ë¡œ ì™„ë£Œ
            textInput.onkeydown = function(e) {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    finishTextInput();
                }
                if (e.key === 'Escape') {
                    textInput.style.display = 'none';
                    textInput.value = '';
                    textInput.onblur = null;
                    textInput.onkeydown = null;
                }
            };
            
            // í¬ì»¤ìŠ¤ ìƒìœ¼ë©´ ì™„ë£Œ
            textInput.onblur = finishTextInput;
        }

        function addTextToCanvas(x, y, text) {
            const brushColor = document.getElementById('brushColor').value;
            const fontSize = 20;
            
            // í…ìŠ¤íŠ¸ ê°ì²´ ìƒì„±
            const textObject = {
                id: objectId++,
                type: 'text',
                layer: currentLayer,
                x: x,
                y: y,
                text: text,
                style: {
                    color: brushColor,
                    font: `${fontSize}px Arial`,
                    fontSize: fontSize
                },
                bounds: {
                    minX: x,
                    maxX: x + text.length * fontSize * 0.6, // ëŒ€ëµì ì¸ í…ìŠ¤íŠ¸ í­
                    minY: y - fontSize,
                    maxY: y
                }
            };
            
            drawingObjects.push(textObject);
            redrawCanvas();
        }

        function redrawCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // ë ˆì´ì–´ë³„ë¡œ ê°ì²´ ë Œë”ë§
            layers.forEach((layer, layerIndex) => {
                if (layer.visible) {
                    // í•´ë‹¹ ë ˆì´ì–´ì˜ ê°ì²´ë“¤ë§Œ ë Œë”ë§
                    const layerObjects = drawingObjects.filter(obj => obj.layer === layerIndex);
                    layerObjects.forEach(obj => {
                        drawObject(ctx, obj);
                    });
                }
            });
            
            // ì„ íƒëœ ê°ì²´ í•˜ì´ë¼ì´íŠ¸
            if (selectedObject) {
                drawObjectHighlight(ctx, selectedObject);
            }
            
            // ë‹¤ì¤‘ ì„ íƒëœ ê°ì²´ë“¤ í•˜ì´ë¼ì´íŠ¸
            selectedObjects.forEach(obj => {
                drawObjectHighlight(ctx, obj);
            });
        }
        
        function drawObject(context, obj) {
            if (obj.type === 'brush' && obj.points.length > 0) {
                context.save();
                context.globalAlpha = obj.style.opacity;
                context.strokeStyle = obj.style.color;
                context.lineWidth = obj.style.size;
                context.lineCap = obj.style.lineCap;
                context.lineJoin = obj.style.lineJoin;
                
                context.beginPath();
                context.moveTo(obj.points[0].x, obj.points[0].y);
                
                for (let i = 1; i < obj.points.length; i++) {
                    context.lineTo(obj.points[i].x, obj.points[i].y);
                }
                
                context.stroke();
                context.restore();
            } else if (obj.type === 'text') {
                context.save();
                context.fillStyle = obj.style.color;
                context.font = obj.style.font;
                context.fillText(obj.text, obj.x, obj.y);
                context.restore();
            } else if (obj.type === 'image' && obj.image) {
                context.save();
                context.drawImage(obj.image, obj.x, obj.y, obj.width, obj.height);
                context.restore();
            }
        }
        
        function drawObjectHighlight(context, obj) {
            context.save();
            context.strokeStyle = '#0066cc';
            context.lineWidth = 2;
            context.setLineDash([5, 5]);
            
            // ê°ì²´ ê²½ê³„ ë°•ìŠ¤ ê·¸ë¦¬ê¸°
            const padding = 5;
            const rect = {
                x: obj.bounds.minX - padding,
                y: obj.bounds.minY - padding,
                width: obj.bounds.maxX - obj.bounds.minX + padding * 2,
                height: obj.bounds.maxY - obj.bounds.minY + padding * 2
            };
            
            context.strokeRect(rect.x, rect.y, rect.width, rect.height);
            
            // í¬ê¸° ì¡°ì • í•¸ë“¤ ê·¸ë¦¬ê¸° (ë‹¨ì¼ ì„ íƒëœ ê°ì²´ë§Œ)
            if (obj === selectedObject) {
                context.setLineDash([]);
                context.fillStyle = '#0066cc';
                context.strokeStyle = '#ffffff';
                context.lineWidth = 1;
                
                const handleSize = 8;
                const handles = [
                    { x: rect.x, y: rect.y }, // nw
                    { x: rect.x + rect.width/2, y: rect.y }, // n
                    { x: rect.x + rect.width, y: rect.y }, // ne
                    { x: rect.x, y: rect.y + rect.height/2 }, // w
                    { x: rect.x + rect.width, y: rect.y + rect.height/2 }, // e
                    { x: rect.x, y: rect.y + rect.height }, // sw
                    { x: rect.x + rect.width/2, y: rect.y + rect.height }, // s
                    { x: rect.x + rect.width, y: rect.y + rect.height } // se
                ];
                
                handles.forEach(handle => {
                    context.fillRect(
                        handle.x - handleSize/2, 
                        handle.y - handleSize/2, 
                        handleSize, 
                        handleSize
                    );
                    context.strokeRect(
                        handle.x - handleSize/2, 
                        handle.y - handleSize/2, 
                        handleSize, 
                        handleSize
                    );
                });
            }
            
            context.restore();
        }
        
        function getObjectAt(x, y) {
            // ì—­ìˆœìœ¼ë¡œ ê²€ì‚¬ (ìœ„ì— ê·¸ë ¤ì§„ ê°ì²´ë¶€í„°)
            for (let i = drawingObjects.length - 1; i >= 0; i--) {
                const obj = drawingObjects[i];
                
                // í˜„ì¬ ë ˆì´ì–´ì˜ ê°ì²´ë§Œ ê²€ì‚¬
                if (obj.layer !== currentLayer || !layers[obj.layer].visible) {
                    continue;
                }
                
                if (isPointInObject(x, y, obj)) {
                    return obj;
                }
            }
            return null;
        }
        
        function isPointInObject(x, y, obj) {
            if (obj.type === 'brush') {
                // ë¨¼ì € ê²½ê³„ ë°•ìŠ¤ í™•ì¸ (ë¹ ë¥¸ ê²€ì‚¬)
                const padding = obj.style.size / 2 + 2;
                if (x < obj.bounds.minX - padding || x > obj.bounds.maxX + padding ||
                    y < obj.bounds.minY - padding || y > obj.bounds.maxY + padding) {
                    return false;
                }
                
                // ë¸ŒëŸ¬ì‹œ ìŠ¤íŠ¸ë¡œí¬ ì„  ìœ„ì˜ ì ì¸ì§€ í™•ì¸
                const threshold = obj.style.size / 2 + 3;
                
                for (let i = 0; i < obj.points.length - 1; i++) {
                    const p1 = obj.points[i];
                    const p2 = obj.points[i + 1];
                    
                    if (distanceToLineSegment(x, y, p1.x, p1.y, p2.x, p2.y) <= threshold) {
                        return true;
                    }
                }
                
                // ë‹¨ì¼ ì ì¸ ê²½ìš°
                if (obj.points.length === 1) {
                    const p = obj.points[0];
                    return Math.sqrt((x - p.x) ** 2 + (y - p.y) ** 2) <= threshold;
                }
            } else if (obj.type === 'text') {
                // í…ìŠ¤íŠ¸ ê²½ê³„ ë°•ìŠ¤ ë‚´ì— ìˆëŠ”ì§€ í™•ì¸
                return x >= obj.bounds.minX && x <= obj.bounds.maxX &&
                       y >= obj.bounds.minY && y <= obj.bounds.maxY;
            }
            return false;
        }
        
        function distanceToLineSegment(px, py, x1, y1, x2, y2) {
            const dx = x2 - x1;
            const dy = y2 - y1;
            const length = Math.sqrt(dx * dx + dy * dy);
            
            if (length === 0) {
                return Math.sqrt((px - x1) ** 2 + (py - y1) ** 2);
            }
            
            const t = Math.max(0, Math.min(1, ((px - x1) * dx + (py - y1) * dy) / (length * length)));
            const projX = x1 + t * dx;
            const projY = y1 + t * dy;
            
            return Math.sqrt((px - projX) ** 2 + (py - projY) ** 2);
        }
        
        function selectObject(obj) {
            selectedObject = obj;
            selectedObjects = []; // ë‹¤ì¤‘ ì„ íƒ í•´ì œ
            selectedArea = null; // ê¸°ì¡´ ì˜ì—­ ì„ íƒ í•´ì œ
            hideSelectionBox();
            redrawCanvas();
            showStatus(`ê°ì²´ ì„ íƒë¨ (ID: ${obj.id})`);
        }
        
        function moveSelectedObject(deltaX, deltaY) {
            if (!selectedObject) return;
            
            if (selectedObject.type === 'brush') {
                // ë¸ŒëŸ¬ì‹œ ìŠ¤íŠ¸ë¡œí¬ì˜ ëª¨ë“  ì  ì´ë™
                selectedObject.points.forEach(point => {
                    point.x += deltaX;
                    point.y += deltaY;
                });
                // ê²½ê³„ ì—…ë°ì´íŠ¸
                selectedObject.bounds.minX += deltaX;
                selectedObject.bounds.maxX += deltaX;
                selectedObject.bounds.minY += deltaY;
                selectedObject.bounds.maxY += deltaY;
            } else if (selectedObject.type === 'text') {
                // í…ìŠ¤íŠ¸ ìœ„ì¹˜ ì´ë™
                selectedObject.x += deltaX;
                selectedObject.y += deltaY;
                // ê²½ê³„ ì—…ë°ì´íŠ¸
                selectedObject.bounds.minX += deltaX;
                selectedObject.bounds.maxX += deltaX;
                selectedObject.bounds.minY += deltaY;
                selectedObject.bounds.maxY += deltaY;
            }
            
            redrawCanvas();
        }
        
        function getResizeHandle(x, y) {
            if (!selectedObject) return null;
            
            const bounds = selectedObject.bounds;
            const handleSize = 8;
            const padding = 5;
            
            // 8ê°œì˜ í¬ê¸° ì¡°ì • í•¸ë“¤ ìœ„ì¹˜ ê³„ì‚°
            const handles = [
                { name: 'nw', x: bounds.minX - padding, y: bounds.minY - padding },
                { name: 'n', x: (bounds.minX + bounds.maxX) / 2, y: bounds.minY - padding },
                { name: 'ne', x: bounds.maxX + padding, y: bounds.minY - padding },
                { name: 'w', x: bounds.minX - padding, y: (bounds.minY + bounds.maxY) / 2 },
                { name: 'e', x: bounds.maxX + padding, y: (bounds.minY + bounds.maxY) / 2 },
                { name: 'sw', x: bounds.minX - padding, y: bounds.maxY + padding },
                { name: 's', x: (bounds.minX + bounds.maxX) / 2, y: bounds.maxY + padding },
                { name: 'se', x: bounds.maxX + padding, y: bounds.maxY + padding }
            ];
            
            // í´ë¦­ ìœ„ì¹˜ê°€ í•¸ë“¤ ë²”ìœ„ ë‚´ì— ìˆëŠ”ì§€ í™•ì¸
            for (let handle of handles) {
                if (x >= handle.x - handleSize/2 && x <= handle.x + handleSize/2 &&
                    y >= handle.y - handleSize/2 && y <= handle.y + handleSize/2) {
                    return handle.name;
                }
            }
            
            return null;
        }
        
        function resizeSelectedObject(currentX, currentY) {
            if (!selectedObject || !currentHandle) return;
            
            const bounds = selectedObject.bounds;
            const originalWidth = bounds.maxX - bounds.minX;
            const originalHeight = bounds.maxY - bounds.minY;
            
            let newBounds = { ...bounds };
            
            // í•¸ë“¤ ìœ„ì¹˜ì— ë”°ë¼ í¬ê¸° ì¡°ì •
            switch (currentHandle) {
                case 'nw':
                    newBounds.minX = currentX;
                    newBounds.minY = currentY;
                    break;
                case 'n':
                    newBounds.minY = currentY;
                    break;
                case 'ne':
                    newBounds.maxX = currentX;
                    newBounds.minY = currentY;
                    break;
                case 'w':
                    newBounds.minX = currentX;
                    break;
                case 'e':
                    newBounds.maxX = currentX;
                    break;
                case 'sw':
                    newBounds.minX = currentX;
                    newBounds.maxY = currentY;
                    break;
                case 's':
                    newBounds.maxY = currentY;
                    break;
                case 'se':
                    newBounds.maxX = currentX;
                    newBounds.maxY = currentY;
                    break;
            }
            
            // ìµœì†Œ í¬ê¸° ì œí•œ
            if (newBounds.maxX - newBounds.minX < 10) return;
            if (newBounds.maxY - newBounds.minY < 10) return;
            
            const scaleX = (newBounds.maxX - newBounds.minX) / originalWidth;
            const scaleY = (newBounds.maxY - newBounds.minY) / originalHeight;
            
            if (selectedObject.type === 'brush') {
                // ë¸ŒëŸ¬ì‹œ ìŠ¤íŠ¸ë¡œí¬ í¬ê¸° ì¡°ì •
                selectedObject.points.forEach(point => {
                    const relativeX = (point.x - bounds.minX) / originalWidth;
                    const relativeY = (point.y - bounds.minY) / originalHeight;
                    point.x = newBounds.minX + relativeX * (newBounds.maxX - newBounds.minX);
                    point.y = newBounds.minY + relativeY * (newBounds.maxY - newBounds.minY);
                });
                // ë¸ŒëŸ¬ì‹œ í¬ê¸°ë„ ìŠ¤ì¼€ì¼ì— ë§ê²Œ ì¡°ì •
                selectedObject.style.size *= Math.min(scaleX, scaleY);
            } else if (selectedObject.type === 'text') {
                // í…ìŠ¤íŠ¸ ìœ„ì¹˜ì™€ í¬ê¸° ì¡°ì •
                const relativeX = (selectedObject.x - bounds.minX) / originalWidth;
                const relativeY = (selectedObject.y - bounds.minY) / originalHeight;
                selectedObject.x = newBounds.minX + relativeX * (newBounds.maxX - newBounds.minX);
                selectedObject.y = newBounds.minY + relativeY * (newBounds.maxY - newBounds.minY);
                
                // í°íŠ¸ í¬ê¸° ì¡°ì •
                selectedObject.style.fontSize *= Math.min(scaleX, scaleY);
                selectedObject.style.font = `${selectedObject.style.fontSize}px Arial`;
            }
            
            selectedObject.bounds = newBounds;
            redrawCanvas();
        }
        
        function handleDoubleClick(e) {
            if (currentTool !== 'select') return;
            
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) / zoomLevel;
            const y = (e.clientY - rect.top) / zoomLevel;
            
            const clickedObject = getObjectAt(x, y);
            if (clickedObject && clickedObject.type === 'text') {
                editTextObject(clickedObject);
            }
        }
        
        function editTextObject(textObj) {
            const textInput = document.getElementById('textInput');
            
            // ê¸°ì¡´ í…ìŠ¤íŠ¸ ë‚´ìš© ì„¤ì •
            textInput.value = textObj.text;
            
            // í…ìŠ¤íŠ¸ ê°ì²´ ìœ„ì¹˜ì— ì…ë ¥ì°½ í‘œì‹œ
            textInput.style.left = (textObj.x * zoomLevel) + 'px';
            textInput.style.top = ((textObj.y - textObj.style.fontSize) * zoomLevel) + 'px';
            textInput.style.fontSize = (textObj.style.fontSize * zoomLevel) + 'px';
            textInput.style.color = textObj.style.color;
            textInput.style.display = 'block';
            textInput.focus();
            textInput.select();
            
            // í¸ì§‘ ì™„ë£Œ ì²˜ë¦¬
            const finishEdit = () => {
                const newText = textInput.value.trim();
                if (newText) {
                    textObj.text = newText;
                    // í…ìŠ¤íŠ¸ ê²½ê³„ ì—…ë°ì´íŠ¸
                    const textWidth = newText.length * textObj.style.fontSize * 0.6;
                    textObj.bounds.maxX = textObj.bounds.minX + textWidth;
                    redrawCanvas();
                }
                textInput.style.display = 'none';
                textInput.value = '';
            };
            
            // ì…ë ¥ì°½ì—ì„œ í¬ì»¤ìŠ¤ ìƒìœ¼ë©´ í¸ì§‘ ì™„ë£Œ
            textInput.onblur = finishEdit;
            
            // Enter í‚¤ë¡œ í¸ì§‘ ì™„ë£Œ
            textInput.onkeydown = function(e) {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    finishEdit();
                }
                if (e.key === 'Escape') {
                    textInput.style.display = 'none';
                    textInput.value = '';
                }
            };
        }
        
        function updateCursorForSelect(x, y) {
            if (selectedObject) {
                const handle = getResizeHandle(x, y);
                if (handle) {
                    // í¬ê¸° ì¡°ì • í•¸ë“¤ì— ë”°ë¥¸ ì»¤ì„œ ë³€ê²½
                    switch(handle) {
                        case 'nw':
                        case 'se':
                            canvas.style.cursor = 'nw-resize';
                            break;
                        case 'ne':
                        case 'sw':
                            canvas.style.cursor = 'ne-resize';
                            break;
                        case 'n':
                        case 's':
                            canvas.style.cursor = 'ns-resize';
                            break;
                        case 'w':
                        case 'e':
                            canvas.style.cursor = 'ew-resize';
                            break;
                    }
                } else if (getObjectAt(x, y)) {
                    canvas.style.cursor = 'move';
                } else {
                    canvas.style.cursor = 'default';
                }
            } else {
                const obj = getObjectAt(x, y);
                if (obj) {
                    canvas.style.cursor = 'pointer';
                } else {
                    canvas.style.cursor = 'default';
                }
            }
        }

        function addLayer() {
            const layerName = prompt('ìƒˆ ë ˆì´ì–´ ì´ë¦„:', `ë ˆì´ì–´ ${layers.length + 1}`);
            if (layerName) {
                layers.push({
                    name: layerName,
                    visible: true,
                    canvas: createLayerCanvas()
                });
                updateLayersList();
            }
        }

        function updateLayersList() {
            const layersList = document.getElementById('layers-list');
            layersList.innerHTML = '';
            
            layers.forEach((layer, index) => {
                const layerItem = document.createElement('div');
                layerItem.className = 'layer-item';
                layerItem.dataset.layer = index;
                
                layerItem.innerHTML = `
                    <input type="checkbox" class="layer-visibility" ${layer.visible ? 'checked' : ''}>
                    <span class="layer-name">${layer.name}</span>
                `;
                
                layersList.appendChild(layerItem);
            });
        }

        function clearCanvas() {
            if (confirm('í˜„ì¬ ë ˆì´ì–´ì˜ ëª¨ë“  ê°ì²´ë¥¼ ì§€ìš°ì‹œê² ìŠµë‹ˆê¹Œ?')) {
                // í˜„ì¬ ë ˆì´ì–´ì˜ ëª¨ë“  ê°ì²´ ì œê±°
                const objectsToRemove = drawingObjects.filter(obj => obj.layer === currentLayer);
                objectsToRemove.forEach(obj => {
                    const index = drawingObjects.indexOf(obj);
                    if (index > -1) {
                        drawingObjects.splice(index, 1);
                    }
                });
                
                // ì„ íƒëœ ê°ì²´ê°€ ì‚­ì œëœ ê²½ìš° ì„ íƒ í•´ì œ
                selectedObject = null;
                selectedObjects = [];
                
                redrawCanvas();
                showStatus(`ë ˆì´ì–´ '${layers[currentLayer].name}'ì˜ ${objectsToRemove.length}ê°œ ê°ì²´ê°€ ì§€ì›Œì¡ŒìŠµë‹ˆë‹¤.`);
            }
        }

        function exportImage() {
            const link = document.createElement('a');
            link.download = 'webtoon.png';
            link.href = canvas.toDataURL();
            link.click();
            showStatus('ì´ë¯¸ì§€ê°€ ë‹¤ìš´ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤.');
        }

        function zoomIn() {
            zoomLevel = Math.min(zoomLevel * 1.2, 5);
            updateZoom();
        }

        function zoomOut() {
            zoomLevel = Math.max(zoomLevel / 1.2, 0.1);
            updateZoom();
        }

        function updateZoom() {
            const canvasArea = document.getElementById('canvasArea');
            canvasArea.style.transform = `scale(${zoomLevel})`;
            document.getElementById('zoomDisplay').textContent = Math.round(zoomLevel * 100) + '%';
        }

        function handleKeydown(e) {
            if (e.ctrlKey || e.metaKey) {
                switch(e.key) {
                    case 'z':
                        e.preventDefault();
                        // ì‹¤í–‰ ì·¨ì†Œ ê¸°ëŠ¥ (ì¶”í›„ êµ¬í˜„)
                        break;
                    case 's':
                        e.preventDefault();
                        exportImage();
                        break;
                }
            }
        }

        function showStatus(message) {
            const statusBar = document.getElementById('statusBar');
            statusBar.textContent = message;
            statusBar.style.display = 'block';
            setTimeout(() => {
                statusBar.style.display = 'none';
            }, 3000);
        }

        // AI ì±— ê¸°ëŠ¥
        function sendMessage() {
            const input = document.getElementById('chatInput');
            const message = input.value.trim();
            
            if (!message) return;
            
            addChatMessage(message, 'user');
            input.value = '';
            
            // "ë°°ê²½" ë‹¨ì–´ ê°ì§€
            if (message.includes('ë°°ê²½')) {
                addChatMessage('ë°°ê²½ ì´ë¯¸ì§€ë¥¼ ì¶”ê°€í•˜ê² ìŠµë‹ˆë‹¤.', 'ai');
                setTimeout(() => {
                    addBackgroundImage();
                }, 1000);
                return;
            }
            
            if (!selectedArea) {
                addChatMessage('ë¨¼ì € í¸ì§‘í•  ì˜ì—­ì„ ì„ íƒí•´ì£¼ì„¸ìš”.', 'ai');
                return;
            }
            
            // AI ì‘ë‹µ ì‹œë®¬ë ˆì´ì…˜
            setTimeout(() => {
                processAIRequest(message);
            }, 1000);
        }

        function addChatMessage(message, sender) {
            const chatMessages = document.getElementById('chatMessages');
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${sender}`;
            messageDiv.textContent = message;
            chatMessages.appendChild(messageDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        function processAIRequest(request) {
            // ì‹¤ì œë¡œëŠ” ì—¬ê¸°ì„œ AI API í˜¸ì¶œ
            const responses = [
                'ì„ íƒëœ ì˜ì—­ì˜ ì´ë¯¸ì§€ í¸ì§‘ì„ ì‹œì‘í•©ë‹ˆë‹¤...',
                'ì›¹íˆ° ìŠ¤íƒ€ì¼ë¡œ ë³€í™˜ ì¤‘ì…ë‹ˆë‹¤...',
                'ìºë¦­í„° í‘œì •ì„ ìˆ˜ì •í•˜ê³  ìˆìŠµë‹ˆë‹¤...',
                'í…ìŠ¤íŠ¸ì™€ ì´ë¯¸ì§€ë¥¼ ì¡°í•©í•˜ì—¬ í¸ì§‘ ì¤‘ì…ë‹ˆë‹¤...',
                'í¸ì§‘ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤! ê²°ê³¼ë¥¼ í™•ì¸í•´ë³´ì„¸ìš”.'
            ];
            
            const response = responses[Math.floor(Math.random() * responses.length)];
            addChatMessage(response, 'ai');
            
            // ê°€ì§œ í¸ì§‘ íš¨ê³¼
            simulateEdit();
        }

        function simulateEdit() {
            if (!selectedArea) return;
            
            const layerCanvas = layers[currentLayer].canvas;
            const layerCtx = layerCanvas.getContext('2d');
            
            // ì„ íƒëœ ì˜ì—­ì— ê°„ë‹¨í•œ íš¨ê³¼ ì ìš©
            layerCtx.save();
            layerCtx.globalAlpha = 0.3;
            layerCtx.fillStyle = '#ff6b6b';
            layerCtx.fillRect(selectedArea.x, selectedArea.y, selectedArea.width, selectedArea.height);
            layerCtx.restore();
            
            redrawCanvas();
            showStatus('AI í¸ì§‘ì´ ì ìš©ë˜ì—ˆìŠµë‹ˆë‹¤!');
        }

        // ë“œë˜ê·¸ ì•¤ ë“œë¡­ ê¸°ëŠ¥
        function setupDragDrop() {
            canvas.addEventListener('dragover', function(e) {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'copy';
            });

            canvas.addEventListener('drop', function(e) {
                e.preventDefault();
                const files = e.dataTransfer.files;
                
                if (files.length > 0) {
                    const file = files[0];
                    if (file.type.startsWith('image/')) {
                        loadImageToCanvas(file);
                    }
                }
            });
        }

        function loadImageToCanvas(file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    const layerCanvas = layers[currentLayer].canvas;
                    const layerCtx = layerCanvas.getContext('2d');
                    
                    // ì´ë¯¸ì§€ë¥¼ ìº”ë²„ìŠ¤ í¬ê¸°ì— ë§ê²Œ ì¡°ì •
                    const scale = Math.min(canvas.width / img.width, canvas.height / img.height);
                    const width = img.width * scale;
                    const height = img.height * scale;
                    const x = (canvas.width - width) / 2;
                    const y = (canvas.height - height) / 2;
                    
                    layerCtx.drawImage(img, x, y, width, height);
                    redrawCanvas();
                    showStatus('ì´ë¯¸ì§€ê°€ ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤.');
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        // ë ˆì´ì–´ ê°€ì‹œì„± í† ê¸€
        document.addEventListener('change', function(e) {
            if (e.target.classList.contains('layer-visibility')) {
                const layerItem = e.target.closest('.layer-item');
                const layerIndex = parseInt(layerItem.dataset.layer);
                layers[layerIndex].visible = e.target.checked;
                redrawCanvas();
                
                const layerName = layers[layerIndex].name;
                showStatus(`ë ˆì´ì–´ '${layerName}' ${e.target.checked ? 'í‘œì‹œ' : 'ìˆ¨ê¹€'}`);
            }
        });

        // ê³ ê¸‰ ë¸ŒëŸ¬ì‹œ ê¸°ëŠ¥
        function setupAdvancedBrush() {
            let lastTime = 0;
            let velocity = 0;
            
            canvas.addEventListener('mousemove', function(e) {
                const currentTime = Date.now();
                const deltaTime = currentTime - lastTime;
                
                if (deltaTime > 0 && isDrawing) {
                    const deltaX = e.movementX || 0;
                    const deltaY = e.movementY || 0;
                    velocity = Math.sqrt(deltaX * deltaX + deltaY * deltaY) / deltaTime;
                    
                    // ì†ë„ì— ë”°ë¥¸ ë¸ŒëŸ¬ì‹œ í¬ê¸° ì¡°ì •
                    const dynamicSize = Math.max(1, document.getElementById('brushSize').value * (1 - velocity * 0.1));
                    
                    if (currentTool === 'brush') {
                        const layerCanvas = layers[currentLayer].canvas;
                        const layerCtx = layerCanvas.getContext('2d');
                        layerCtx.lineWidth = dynamicSize;
                    }
                }
                
                lastTime = currentTime;
            });
        }



        // ì‹¤í–‰ ì·¨ì†Œ/ë‹¤ì‹œ ì‹¤í–‰ ê¸°ëŠ¥
        let history = [];
        let historyStep = -1;

        function saveState() {
            historyStep++;
            if (historyStep < history.length) {
                history.length = historyStep;
            }
            
            const state = layers.map(layer => {
                const canvas = document.createElement('canvas');
                canvas.width = layer.canvas.width;
                canvas.height = layer.canvas.height;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(layer.canvas, 0, 0);
                return {
                    name: layer.name,
                    visible: layer.visible,
                    canvas: canvas
                };
            });
            
            history.push(state);
            
            // íˆìŠ¤í† ë¦¬ í¬ê¸° ì œí•œ
            if (history.length > 20) {
                history.shift();
                historyStep--;
            }
        }

        function undo() {
            if (historyStep > 0) {
                historyStep--;
                restoreState(history[historyStep]);
                showStatus('ì‹¤í–‰ ì·¨ì†Œ');
            }
        }

        function redo() {
            if (historyStep < history.length - 1) {
                historyStep++;
                restoreState(history[historyStep]);
                showStatus('ë‹¤ì‹œ ì‹¤í–‰');
            }
        }

        function restoreState(state) {
            layers = state.map(layerState => ({
                name: layerState.name,
                visible: layerState.visible,
                canvas: layerState.canvas
            }));
            
            updateLayersList();
            redrawCanvas();
        }

        // í‚¤ë³´ë“œ ë‹¨ì¶•í‚¤ ì—…ë°ì´íŠ¸
        function handleKeydown(e) {
            if (e.ctrlKey || e.metaKey) {
                switch(e.key) {
                    case 'z':
                        e.preventDefault();
                        if (e.shiftKey) {
                            redo();
                        } else {
                            undo();
                        }
                        break;
                    case 's':
                        e.preventDefault();
                        exportImage();
                        break;
                    case 'a':
                        e.preventDefault();
                        selectAllArea();
                        break;
                }
            }
            
            // ê°ì²´ ì¡°ì‘ ë‹¨ì¶•í‚¤
            if (e.key === 'Delete' || e.key === 'Backspace') {
                if (selectedObject || selectedObjects.length > 0) {
                    deleteSelectedObjects();
                    e.preventDefault();
                }
            }
            
            // ESCë¡œ ì„ íƒ í•´ì œ
            if (e.key === 'Escape') {
                selectedObject = null;
                selectedObjects = [];
                selectedArea = null;
                hideSelectionBox();
                redrawCanvas();
                showStatus('ì„ íƒ í•´ì œë¨');
            }
            
            // ë„êµ¬ ë‹¨ì¶•í‚¤
            switch(e.key) {
                case 'v':
                    selectTool('select');
                    break;
                case 'b':
                    selectTool('brush');
                    break;
                case 'e':
                    selectTool('eraser');
                    break;
                case 't':
                    selectTool('text');
                    break;
            }
        }
        
        function deleteSelectedObjects() {
            let deletedCount = 0;
            
            // ë‹¨ì¼ ì„ íƒëœ ê°ì²´ ì‚­ì œ
            if (selectedObject) {
                const index = drawingObjects.indexOf(selectedObject);
                if (index > -1) {
                    drawingObjects.splice(index, 1);
                    deletedCount++;
                }
                selectedObject = null;
            }
            
            // ë‹¤ì¤‘ ì„ íƒëœ ê°ì²´ë“¤ ì‚­ì œ
            if (selectedObjects.length > 0) {
                selectedObjects.forEach(obj => {
                    const index = drawingObjects.indexOf(obj);
                    if (index > -1) {
                        drawingObjects.splice(index, 1);
                        deletedCount++;
                    }
                });
                selectedObjects = [];
            }
            
            if (deletedCount > 0) {
                showStatus(`${deletedCount}ê°œ ê°ì²´ ì‚­ì œë¨`);
                redrawCanvas();
            }
        }

        function selectAllArea() {
            selectedArea = {
                x: 0,
                y: 0,
                width: canvas.width,
                height: canvas.height
            };
            
            const selectionBox = document.getElementById('selectionBox');
            selectionBox.style.left = '0px';
            selectionBox.style.top = '0px';
            selectionBox.style.width = canvas.width * zoomLevel + 'px';
            selectionBox.style.height = canvas.height * zoomLevel + 'px';
            selectionBox.style.display = 'block';
            
            showStatus('ì „ì²´ ì˜ì—­ì´ ì„ íƒë˜ì—ˆìŠµë‹ˆë‹¤.');
        }

        // ì´ˆê¸°í™” í•¨ìˆ˜ë“¤ í˜¸ì¶œ
        setTimeout(() => {
            setupDragDrop();
            setupAdvancedBrush();
            saveState(); // ì´ˆê¸° ìƒíƒœ ì €ì¥
        }, 100);

        // Enter í‚¤ë¡œ ì±„íŒ… ì „ì†¡
        document.getElementById('chatInput').addEventListener('keydown', function(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        });

        // ìºë¦­í„° ë ˆí¼ëŸ°ìŠ¤ ì‹œìŠ¤í…œ
        function setupCharacterSystem() {
            const uploadArea = document.getElementById('uploadArea');
            const fileInput = document.getElementById('characterFileInput');
            const imagePreview = document.getElementById('imagePreview');

            // ë“œë˜ê·¸ ì•¤ ë“œë¡­
            uploadArea.addEventListener('dragover', function(e) {
                e.preventDefault();
                uploadArea.classList.add('dragover');
            });

            uploadArea.addEventListener('dragleave', function(e) {
                e.preventDefault();
                uploadArea.classList.remove('dragover');
            });

            uploadArea.addEventListener('drop', function(e) {
                e.preventDefault();
                uploadArea.classList.remove('dragover');
                const files = e.dataTransfer.files;
                if (files.length > 0 && files[0].type.startsWith('image/')) {
                    handleCharacterImageUpload(files[0]);
                }
            });

            // í´ë¦­ ì—…ë¡œë“œ
            uploadArea.addEventListener('click', function() {
                fileInput.click();
            });

            fileInput.addEventListener('change', function(e) {
                if (e.target.files.length > 0) {
                    handleCharacterImageUpload(e.target.files[0]);
                }
            });

            // ìºë¦­í„° ê°¤ëŸ¬ë¦¬ ì´ë²¤íŠ¸
            setupCharacterGalleryEvents();
        }

        function handleCharacterImageUpload(file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                const imagePreview = document.getElementById('imagePreview');
                const uploadContent = document.querySelector('.upload-content');
                
                imagePreview.src = e.target.result;
                imagePreview.style.display = 'block';
                uploadContent.style.display = 'none';
            };
            reader.readAsDataURL(file);
        }

        function addCharacterReference() {
            document.getElementById('characterModal').style.display = 'flex';
            resetCharacterModal();
        }

        function resetCharacterModal() {
            const imagePreview = document.getElementById('imagePreview');
            const uploadContent = document.querySelector('.upload-content');
            const nameInput = document.getElementById('characterNameInput');
            
            imagePreview.style.display = 'none';
            uploadContent.style.display = 'block';
            nameInput.value = '';
            document.getElementById('characterFileInput').value = '';
        }

        function closeCharacterModal() {
            document.getElementById('characterModal').style.display = 'none';
        }

        function saveCharacterReference() {
            const imagePreview = document.getElementById('imagePreview');
            const nameInput = document.getElementById('characterNameInput');
            
            if (!imagePreview.src || imagePreview.style.display === 'none') {
                alert('ìºë¦­í„° ì´ë¯¸ì§€ë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”.');
                return;
            }
            
            if (!nameInput.value.trim()) {
                alert('ìºë¦­í„° ì´ë¦„ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.');
                return;
            }

            const character = {
                id: Date.now(),
                name: nameInput.value.trim(),
                image: imagePreview.src,
                timestamp: new Date().toISOString()
            };

            characterReferences.push(character);
            updateCharacterGallery();
            closeCharacterModal();
            showStatus(`ìºë¦­í„° '${character.name}' ì¶”ê°€ë¨`);
        }

        function updateCharacterGallery() {
            const gallery = document.getElementById('character-gallery');
            
            // ê¸°ì¡´ ìºë¦­í„°ë“¤ í‘œì‹œ
            gallery.innerHTML = '';
            
            characterReferences.forEach(character => {
                const slot = document.createElement('div');
                slot.className = 'character-slot';
                slot.style.backgroundImage = `url(${character.image})`;
                slot.dataset.characterId = character.id;
                
                slot.innerHTML = `
                    <div class="character-controls">
                        <button class="delete-character" onclick="deleteCharacter(${character.id})" title="ì‚­ì œ">Ã—</button>
                    </div>
                    <div class="character-info">
                        <div>${character.name}</div>
                    </div>
                `;
                
                slot.addEventListener('click', function(e) {
                    if (!e.target.classList.contains('delete-character')) {
                        selectCharacterReference(character.id);
                    }
                });
                
                // íˆ´íŒ ì´ë²¤íŠ¸
                slot.addEventListener('mouseenter', function(e) {
                    showCharacterTooltip(e, character);
                });
                
                slot.addEventListener('mouseleave', function() {
                    hideCharacterTooltip();
                });
                
                gallery.appendChild(slot);
            });
            
            // ìƒˆ ìºë¦­í„° ì¶”ê°€ ìŠ¬ë¡¯
            if (characterReferences.length < 6) { // ìµœëŒ€ 6ê°œ ì œí•œ
                const addSlot = document.createElement('div');
                addSlot.className = 'character-slot empty';
                addSlot.onclick = addCharacterReference;
                addSlot.innerHTML = `
                    <div class="add-character">
                        <span>+</span>
                        <p>ìºë¦­í„° ì¶”ê°€</p>
                    </div>
                `;
                gallery.appendChild(addSlot);
            }
        }

        function selectCharacterReference(characterId) {
            // ì´ì „ ì„ íƒ í•´ì œ
            document.querySelectorAll('.character-slot').forEach(slot => {
                slot.classList.remove('selected');
            });
            
            // ìƒˆ ì„ íƒ
            const slot = document.querySelector(`[data-character-id="${characterId}"]`);
            if (slot) {
                slot.classList.add('selected');
                selectedCharacter = characterReferences.find(char => char.id === characterId);
                showStatus(`ìºë¦­í„° '${selectedCharacter.name}' ì„ íƒë¨`);
            }
        }

        function deleteCharacter(characterId) {
            if (confirm('ì´ ìºë¦­í„°ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
                characterReferences = characterReferences.filter(char => char.id !== characterId);
                if (selectedCharacter && selectedCharacter.id === characterId) {
                    selectedCharacter = null;
                }
                updateCharacterGallery();
                showStatus('ìºë¦­í„°ê°€ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.');
            }
        }

        function showCharacterTooltip(event, character) {
            const tooltip = document.getElementById('characterTooltip');
            tooltip.innerHTML = `
                <img src="${character.image}" alt="${character.name}">
                <div><strong>${character.name}</strong></div>
                <div style="color: #aaa; font-size: 10px;">ì¶”ê°€ì¼: ${new Date(character.timestamp).toLocaleDateString()}</div>
            `;
            
            const rect = event.target.getBoundingClientRect();
            tooltip.style.left = (rect.right + 10) + 'px';
            tooltip.style.top = rect.top + 'px';
            tooltip.style.display = 'block';
        }

        function hideCharacterTooltip() {
            document.getElementById('characterTooltip').style.display = 'none';
        }

        function setupCharacterGalleryEvents() {
            // ê°¤ëŸ¬ë¦¬ ì™¸ë¶€ í´ë¦­ì‹œ ì„ íƒ í•´ì œ
            document.addEventListener('click', function(e) {
                if (!e.target.closest('#character-gallery')) {
                    document.querySelectorAll('.character-slot').forEach(slot => {
                        slot.classList.remove('selected');
                    });
                    selectedCharacter = null;
                }
            });
        }

        // ë ˆí¼ëŸ°ìŠ¤ë¡œ ìƒì„± ê¸°ëŠ¥
        function generateWithReference() {
            if (!selectedCharacter) {
                addChatMessage('ë¨¼ì € ìºë¦­í„°ë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”.', 'ai');
                return;
            }
            
            if (!selectedArea) {
                addChatMessage('í¸ì§‘í•  ì˜ì—­ì„ ë¨¼ì € ì„ íƒí•´ì£¼ì„¸ìš”.', 'ai');
                return;
            }
            
            const message = selectedCharacter ? 
                `ì„ íƒëœ ìºë¦­í„° '${selectedCharacter.name}'ì˜ ë ˆí¼ëŸ°ìŠ¤ë¥¼ Nano Bananaë¥¼ ì‚¬ìš©í•˜ì—¬ ì´ë¯¸ì§€ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.` :
                `Nano Bananaë¥¼ ì‚¬ìš©í•˜ì—¬ ì´ë¯¸ì§€ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.`;
            addChatMessage(message, 'ai');
            
            // AI ì²˜ë¦¬ ì‹œë®¬ë ˆì´ì…˜
            setTimeout(() => {
                const responses = selectedCharacter ? [
                    `${selectedCharacter.name}ì˜ ìŠ¤íƒ€ì¼ì„ ë¶„ì„í•˜ê³  ìˆìŠµë‹ˆë‹¤...`,
                    'ì¼ê´€ëœ ìºë¦­í„° íŠ¹ì§•ì„ ì ìš©í•˜ì—¬ ì´ë¯¸ì§€ë¥¼ ìƒì„± ì¤‘ì…ë‹ˆë‹¤...',
                    'ë ˆí¼ëŸ°ìŠ¤ ê¸°ë°˜ ì›¹íˆ° ìŠ¤íƒ€ì¼ ë³€í™˜ì„ ì§„í–‰í•©ë‹ˆë‹¤...',
                    `${selectedCharacter.name}ì˜ íŠ¹ì§•ì„ ìœ ì§€í•˜ë©° í¸ì§‘ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤!`
                ] : [
                    'Nano Banana AIê°€ ì´ë¯¸ì§€ ë¶„ì„ì„ ì‹œì‘í•©ë‹ˆë‹¤...',
                    'ì›¹íˆ° ìŠ¤íƒ€ì¼ë¡œ ì´ë¯¸ì§€ë¥¼ ë³€í™˜ ì¤‘ì…ë‹ˆë‹¤...',
                    'ê³ í’ˆì§ˆ ê²°ê³¼ë¬¼ì„ ìƒì„±í•˜ê³  ìˆìŠµë‹ˆë‹¤...',
                    'Nano Banana AI í¸ì§‘ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤!'
                ];
                
                responses.forEach((response, index) => {
                    setTimeout(() => {
                        addChatMessage(response, 'ai');
                        if (index === responses.length - 1) {
                            simulateCharacterEdit();
                        }
                    }, (index + 1) * 1500);
                });
            }, 500);
        }

        function simulateCharacterEdit() {
            console.log('simulateCharacterEdit ì‹œì‘');
            console.log('selectedArea:', selectedArea);
            
            if (!selectedArea) {
                console.log('selectedAreaê°€ ì—†ì–´ì„œ ì¢…ë£Œ');
                return;
            }
            
            const layerCanvas = layers[currentLayer].canvas;
            const layerCtx = layerCanvas.getContext('2d');
            
            console.log('í˜„ì¬ ë ˆì´ì–´:', currentLayer);
            console.log('layerCanvas í¬ê¸°:', layerCanvas.width, 'x', layerCanvas.height);
            
            // ì§€ì •ëœ ê²°ê³¼ ì´ë¯¸ì§€ë¡œ í¸ì§‘ ì‹œë®¬ë ˆì´ì…˜
            const resultImg = new Image();
            resultImg.onload = function() {
                console.log('ì´ë¯¸ì§€ ë¡œë“œ ì™„ë£Œ');
                console.log('ì´ë¯¸ì§€ í¬ê¸°:', resultImg.width, 'x', resultImg.height);
                
                // ì„ íƒ ì˜ì—­ì— ë§ê²Œ ì´ë¯¸ì§€ í¬ê¸° ì¡°ì •
                const scale = Math.min(selectedArea.width / resultImg.width, selectedArea.height / resultImg.height);
                const width = resultImg.width * scale;
                const height = resultImg.height * scale;
                const x = selectedArea.x + (selectedArea.width - width) / 2;
                const y = selectedArea.y + (selectedArea.height - height) / 2;
                
                console.log('ê·¸ë¦¬ê¸° ê³„ì‚°ëœ ê°’ë“¤:', { scale, width, height, x, y });
                
                // ì´ë¯¸ì§€ë¥¼ ê°ì²´ë¡œ ì¶”ê°€ (ë ˆì´ì–´ ìº”ë²„ìŠ¤ì— ì§ì ‘ ê·¸ë¦¬ì§€ ì•ŠìŒ)
                const imageObject = {
                    id: objectId++,
                    type: 'image',
                    layer: currentLayer,
                    x: x,
                    y: y,
                    width: width,
                    height: height,
                    image: resultImg,
                    bounds: { minX: x, maxX: x + width, minY: y, maxY: y + height }
                };
                
                drawingObjects.push(imageObject);
                
                console.log('ì´ë¯¸ì§€ ê°ì²´ ì¶”ê°€ë¨, redrawCanvas í˜¸ì¶œ');
                redrawCanvas();
                showStatus('Nano Banana AI í¸ì§‘ ì™„ë£Œ!');
            };
            
            // ì´ë¯¸ì§€ ë¡œë“œ ì‹¤íŒ¨ ì‹œ ê¸°ë³¸ íš¨ê³¼
            resultImg.onerror = function(error) {
                console.error('ì´ë¯¸ì§€ ë¡œë“œ ì‹¤íŒ¨:', error);
                console.error('ì´ë¯¸ì§€ src:', resultImg.src);
                layerCtx.save();
                layerCtx.globalAlpha = 0.3;
                layerCtx.fillStyle = '#ff6b6b';
                layerCtx.fillRect(selectedArea.x, selectedArea.y, selectedArea.width, selectedArea.height);
                layerCtx.restore();
                redrawCanvas();
                showStatus('ê²°ê³¼ ì´ë¯¸ì§€ë¥¼ ë¡œë“œí•  ìˆ˜ ì—†ì–´ ê¸°ë³¸ íš¨ê³¼ë¥¼ ì ìš©í–ˆìŠµë‹ˆë‹¤.');
            };
            
            resultImg.crossOrigin = 'anonymous'; // CORS ë¬¸ì œ ë°©ì§€
            const imagePath = './character_result.png?t=' + Date.now();
            console.log('ì´ë¯¸ì§€ ë¡œë“œ ì‹œì‘:', imagePath);
            resultImg.src = imagePath;
        }

        // ìºë¦­í„° ì¶”ì¶œ ê¸°ëŠ¥
        function extractCharacter() {
            if (!selectedArea) {
                addChatMessage('ì¶”ì¶œí•  ì˜ì—­ì„ ë¨¼ì € ì„ íƒí•´ì£¼ì„¸ìš”.', 'ai');
                return;
            }
            
            // ì„ íƒëœ ì˜ì—­ì—ì„œ ìºë¦­í„° ì¶”ì¶œ
            const extractedData = ctx.getImageData(selectedArea.x, selectedArea.y, selectedArea.width, selectedArea.height);
            
            // ì„ì‹œ ìº”ë²„ìŠ¤ì— ì¶”ì¶œëœ ì´ë¯¸ì§€ ê·¸ë¦¬ê¸°
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = selectedArea.width;
            tempCanvas.height = selectedArea.height;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.putImageData(extractedData, 0, 0);
            
            // ì¶”ì¶œëœ ì´ë¯¸ì§€ë¥¼ ìºë¦­í„°ë¡œ ì¶”ê°€í• ì§€ í™•ì¸
            if (confirm('ì„ íƒëœ ì˜ì—­ì„ ìƒˆ ìºë¦­í„° ë ˆí¼ëŸ°ìŠ¤ë¡œ ì¶”ê°€í•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
                const characterName = prompt('ìºë¦­í„° ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”:', 'ì¶”ì¶œëœ ìºë¦­í„°');
                if (characterName) {
                    const character = {
                        id: Date.now(),
                        name: characterName,
                        image: tempCanvas.toDataURL(),
                        timestamp: new Date().toISOString()
                    };
                    
                    characterReferences.push(character);
                    updateCharacterGallery();
                    showStatus(`ìºë¦­í„° '${characterName}' ì¶”ì¶œ ì™„ë£Œ!`);
                }
            }
        }

        // AI ë©”ì‹œì§€ ì²˜ë¦¬ ì—…ë°ì´íŠ¸
        function processAIRequest(request) {
            let responses = [];
            
            if (selectedCharacter) {
                responses = [
                    `'${selectedCharacter.name}' ìºë¦­í„° ë ˆí¼ëŸ°ìŠ¤ë¥¼ ê¸°ë°˜ìœ¼ë¡œ í¸ì§‘ì„ ì‹œì‘í•©ë‹ˆë‹¤...`,
                    'ì¼ê´€ëœ ìºë¦­í„° ìŠ¤íƒ€ì¼ì„ ìœ ì§€í•˜ë©° ì´ë¯¸ì§€ë¥¼ ìƒì„± ì¤‘ì…ë‹ˆë‹¤...',
                    'Nano Banana ìŠ¤íƒ€ì¼ì˜ ì›¹íˆ° ë³€í™˜ì„ ì ìš©í•˜ê³  ìˆìŠµë‹ˆë‹¤...',
                    `${selectedCharacter.name}ì˜ íŠ¹ì§•ì„ ì‚´ë¦° í¸ì§‘ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤!`
                ];
            } else {
                responses = [
                    'ì„ íƒëœ ì˜ì—­ì˜ ì´ë¯¸ì§€ í¸ì§‘ì„ ì‹œì‘í•©ë‹ˆë‹¤...',
                    'ì›¹íˆ° ìŠ¤íƒ€ì¼ë¡œ ë³€í™˜ ì¤‘ì…ë‹ˆë‹¤...',
                    'í¸ì§‘ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤! ìºë¦­í„° ë ˆí¼ëŸ°ìŠ¤ë¥¼ ì¶”ê°€í•˜ì‹œë©´ ë” ì¼ê´€ëœ ê²°ê³¼ë¥¼ ì–»ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.'
                ];
            }
            
            responses.forEach((response, index) => {
                setTimeout(() => {
                    addChatMessage(response, 'ai');
                    if (index === responses.length - 1) {
                        if (selectedCharacter) {
                            simulateCharacterEdit();
                        } else {
                            simulateEdit();
                        }
                    }
                }, (index + 1) * 1000);
            });
        }
    </script>
</body>
</html>